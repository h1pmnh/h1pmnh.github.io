[{"body":"","link":"https://h1pmnh.github.io/","section":"","tags":null,"title":""},{"body":"","link":"https://h1pmnh.github.io/tags/csrf/","section":"tags","tags":null,"title":"csrf"},{"body":"","link":"https://h1pmnh.github.io/tags/ctf/","section":"tags","tags":null,"title":"ctf"},{"body":"Summary Genesis Wallet was one of the harder web challenges in the 2022 Hack the Box (HTB) CTF. Our team composed of Synack Red Team members finished a respectable 21st place, unfortunately we were very close to solving this challenge and literally were about 5 minutes from a successful solve when time expired - so sad!\nPersonally I thought this was a very clever challenge and probably one of the best designed web challenges in any CTF I've done to date, so I thought I'd share it with interested readers.\nSetup You are presented with the Genesis Wallet system, an online site that is used to transfer GTC tokens from one wallet address to another. You are provided with a set of credentials (username icarus and corresponding password) for a wallet and can log in using these credentials - BUT the site is protected by 2FA and requires you to also have an OTP code to log in.\nAs with the other HTB CTF challenges, we're provided with the full code of the application, which makes finding the path to the flag slightly easier.\nApplication Architecture This application is a NodeJS application running in a Docker container. It is fronted by a Varnish proxy server and has a SQLite database behind it.\nFinding the Flag With many of the white box challenges in this CTF, it is fairly easy to locate where the flag is available - the challenge is getting to it in the running web application!\nIn this case we can look at the routes/index.js file and see that the flag is displayed on the main application dashboard under certain conditions:\n1router.get(/^\\/(\\w{2})?\\/?dashboard/, AuthMiddleware, async (req, res) =\u0026gt; { 2\tlet lang = req.params[0]; 3\tif (!lang) lang = \u0026#39;en\u0026#39;; 4 5\treturn db.getUser(req.user.username) 6\t.then(user =\u0026gt; { 7\tlet flag = null; 8\tif (user.balance \u0026gt; 1337 \u0026amp;\u0026amp; user.username != \u0026#39;icarus\u0026#39;) flag = fs.readFileSync(\u0026#39;/flag.txt\u0026#39;).toString(); 9\tres.render(`${lang}/dashboard.html`, { user, flag }); So we can see that in order to display the flag we need to satisfy the following conditions:\nNeed to have a wallet balance which is substantial (\u0026gt;1337 GTC) Need to be logged in as a user who is not icarus (the credentials we are provided with the challenge) Initial Setup - New Account The site supports self registration functionality that proceeds as follows:\nRegister new username / password Log in with username / password Register 2FA QR code with authenticator Confirm OTP from authenticator When we create a new account, we discover that new users are granted 0.1 GTC free into their wallet. Based on the market cap of the GTC token this is very generous ;)\nIf we need to reach a balance greater than 1337 GTC this will require a lot of accounts and a lot of consolidation of \u0026quot;free\u0026quot; GTC tokens. There must be a way to get more tokens into an account we control!\nFinding the Tokens Let's look at how the database is seeded, maybe this will help us find a wallet with a balance? In database.js, which is used at startup of the NodeJS applcation to seed the database, we see the following:\n1\tasync migrate() { 2\tlet uOTPKey = OTPHelper.genSecret(); 3\tlet uAddress = crypto.createHash(\u0026#39;md5\u0026#39;).update(\u0026#39;icarus\u0026#39;).digest(\u0026#34;hex\u0026#34;); 4\treturn this.db.exec(` 5\tDROP TABLE IF EXISTS users; 6\tCREATE TABLE users ( 7\tid INTEGER NOT NULL PRIMARY KEY AUTOINCREMENT, 8\tusername VARCHAR(255) NOT NULL UNIQUE, 9\tpassword VARCHAR(255) NOT NULL, 10\tbalance DOUBLE DEFAULT 0.100, 11\totpkey VARCHAR(255) NULL, 12\taddress VARCHAR(36) NOT NULL UNIQUE 13\t); 14 15\tINSERT OR IGNORE INTO users (username, password, balance, otpkey, address) 16\tVALUES (\u0026#39;icarus\u0026#39;, \u0026#39;FlyHighToTheSky\u0026#39;, 1337.10, \u0026#39;${uOTPKey}\u0026#39;, \u0026#39;${uAddress}\u0026#39;); So we see that the user icarus has a wallet balance that is seeded with a little more GTC tokens than we need to satisfy the first flag criteria. To satisfy the second criteria, we need that balance to be in a wallet which is not controlled by the user icarus - so how can we manage a transfer of funds to our wallet?\nSteps to Transfer Funds After experimenting with the functionality of the site, we learn the flow to send funds from one wallet to another is as follows:\nSender intiates a transaction The transaction includes the receiver's wallet address and amount The transaction may include a note, specified in Markdown Sender confirms the transaction with their OTP Receiver can see the transaction on their dashboard and the funds are added to their wallet The transaction note specified in Markdown seems interesting, and I immediately thought that this could be an easy CSRF via XSS (a theme very common in web CTF challenges), however in this case we face the dreaded DOMPurify as can be seen in the NodeJS function responsible for converting the Markdown to HTML for rendering (located in helpers/MDHelper.js):\n1const showdown = require(\u0026#39;showdown\u0026#39;) 2const createDOMPurify = require(\u0026#39;dompurify\u0026#39;); 3const { JSDOM } = require(\u0026#39;jsdom\u0026#39;); 4 5const conv = new showdown.Converter({ 6\tcompleteHTMLDocument: false, 7 [...snip...] 8}); 9const makeHtml = (md) =\u0026gt; { 10 return(conv.makeHtml(md)); 11} 12const filterHTML = (content) =\u0026gt; { 13 html = makeHtml(content); 14 window = new JSDOM(\u0026#39;\u0026#39;).window; 15 DOMPurify = createDOMPurify(window); 16 return DOMPurify.sanitize(html, {ALLOWED_TAGS: [\u0026#39;strong\u0026#39;, \u0026#39;em\u0026#39;, \u0026#39;img\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;ul\u0026#39;, \u0026#39;ol\u0026#39;, \u0026#39;li\u0026#39;]}); 17} So we see that the showdown converter is used to convert Markdown to HTML, and the result is run through DOMPurify with a very restricted list of supported tags. I hoped that there was some trick here where an older / vulnerable version of DOMPurify was in use (we've seen this in several CTFs recently) but unfortunately this was not the case.\nFraming the Solution: CSRF via \u0026lt;img\u0026gt; tag After thinking about this for a bit, I realized that we had the potential to submit an \u0026lt;img\u0026gt; tag with an src= attribute that could invoke a GET-based CSRF attack, when the receiver (icarus) views the transaction.\nSide Quest: Finding icarus's Wallet Before I could test this theory, I had to solve the practical problem of not knowing what the wallet address for icarus was. Fortunately this was easily determined by running the code in the database seeding script in the Node CLI:\n1$ node 2\u0026gt; crypto.createHash(\u0026#39;md5\u0026#39;).update(\u0026#39;icarus\u0026#39;).digest(\u0026#34;hex\u0026#34;); 3\u0026#39;1ea8b3ac0640e44c27b3cb8a258a87f8\u0026#39; Next Steps: Finding a CSRF Fortunately there were not too many routes in this Node application, and I knew I had to find something that was GET-based and 2FA-related. After some code review I came upon the code to handle the initial setup (or resetting) of a user's 2FA authenticator application:\n1router.get(/^\\/(\\w{2})?\\/?(setup|reset)-2fa/, AuthMiddleware, async (req, res) =\u0026gt; { 2\tlet lang = req.params[0]; 3\tif (!lang) lang = \u0026#39;en\u0026#39;; 4\tlet otpkey = OTPHelper.genSecret(); 5 6\treturn db.setOTPKey(req.user.username, otpkey) 7\t.then(() =\u0026gt; { 8\treturn res.render(`${lang}/setup-2fa.html`, {otpkey: otpkey, action: req.params[1]}); We can see that, when invoked, this URL will generate a new OTP key for the currently logged-in user, save it to the database, and then display the key to them in their browser. Can you spot the critical bug here?\nThat's right - the new OTP key is saved to the database before being confirmed by the user. This is a pretty bad design because if the user doesn't confirm that they have scanned the QR into their authenticator app, they could be permanently locked out of their account (having reset the OTP without actually confirming that they have it!).\nSo, in theory this means that we can send a transaction note with the following HTML content to trigger generation of a new OTP key for the user receiving our transaction:\n1\u0026lt;img src=\u0026#34;/reset-2fa\u0026#34;\u0026gt; Of course we need to convert this into Markdown for use in the note:\n1![](/reset-2fa) We have a big problem though - how does this help in our quest to steal funds from icarus's wallet?\nExplainer: OTP Keys and 2FA via TOTP As a very brief explanation of what OTP keys are - most TOTP solutions rely on the creation of a shared secret, which is known by the server and the client. They use the same algorithm, seeded with this secret, to generate (client) and confirm (server) that the time-based codes are correct.\nKnowledge of this secret can lead to an attacker being able to generate their own TOTP codes which are guaranteed to be in sync with any other client as well as the server. This is well explained in the Wikipedia Article on TOTP codes.\nConfirming the CSRF As a quick confirmation, we created a transaction and sent it to the icarus wallet address containing an image that pointed to Burp Collaborator. We confirmed that shortly after the transaction was confirmed by the sender, the \u0026lt;img\u0026gt; tag was hit. Examining the code of the application, in bot.js we can see that there is code to log into the application and view the \u0026quot;transactions\u0026quot; page after every confirmed transaction:\n1const viewTransactions = async () =\u0026gt; { 2 try { 3\tconst browser = await puppeteer.launch(browser_options); 4\tlet context = await browser.createIncognitoBrowserContext(); 5\tlet page = await context.newPage(); 6 7\tlet token = await JWTHelper.sign({ username: \u0026#39;icarus\u0026#39;, otpkey: true, verified: true }); 8\tawait page.setCookie({ 9\tname: \u0026#34;session\u0026#34;, 10\t\u0026#39;value\u0026#39;: token, 11\tdomain: \u0026#34;127.0.0.1\u0026#34; 12\t}); 13\tawait page.goto(\u0026#39;http://127.0.0.1/transactions\u0026#39;, { 14\twaitUntil: \u0026#39;networkidle2\u0026#39;, So it seems we are onto something with this CSRF idea since there is clearly a headless browser that is intended to view the transaction note.\nThe Final Puzzle Piece - Grabbing the OTP secret This last piece actually took me a while to think through - we need to be able to view the content of the /reset-2fa page after it has been requested by icarus from our CSRF attack. How would we do this?\nFor anyone who plays CTFs regularly you know that usually \u0026quot;things are there for a reason\u0026quot; is an axiom you can follow if you get stuck for ideas. It occurred to me to look at the Varnish proxy configuration and then the final piece of the puzzle became clear. Let's look at config/cache.vcl, which is the Varnish Cache configuation file, written in VCL, the Varnish language. Particularly, this piece stood out to me:\n1sub vcl_recv { 2 # Only allow caching for GET and HEAD requests 3 if (req.method != \u0026#34;GET\u0026#34; \u0026amp;\u0026amp; req.method != \u0026#34;HEAD\u0026#34;) { 4 return (pass); 5 } 6 # get javascript and css from cache 7 if (req.url ~ \u0026#34;(\\.(js|css|map)$|\\.(js|css)\\?version|\\.(js|css)\\?t)\u0026#34;) { 8 return (hash); 9 } 10 # get images from cache 11 if (req.url ~ \u0026#34;\\.(svg|ico|jpg|jpeg|gif|png)$\u0026#34;) { 12 return (hash); 13 } We can see that Varnish is configured to cache any URL matching these regexes for static content. Crucially, it's important to note that the req.url value is the full URL of the request and not just the portion before any query string. This means that the following URL will be cached by Varnish:\n1/reset-2fa?ctf.jpg This was the final piece of the puzzle that was needed to grab the OTP secret. Basically, by adding a query string value that will trigger the Varnish caching of the page content, any other request to that same URL should return the same content until the Varnish cache TTL (in this case set to 2 minutes) expires. This should allow us to view the contents of the cached page which was rendered to icarus when the CSRF request took place!\nThis was a brilliant use of reverse cache poisoning, where we are forcing sensitive data to be cached such that an attacker can read it. Truly a brilliant design choice for this challenge!\nAssembling the Final Payload We now have all the steps requires to complete the mission:\nSend icarus a small transaction with a note containing the Markdown ![](/reset-2fa?123.jpg) When viewed, this will trigger a CSRF which will store a new OTP key in icarus's database account The content of the request will be (incorrectly) cached by Varnish We can request the same page to see the cached content We can use the OTP secret to configure our TOTP authenticator app to generate codes allowing us to log into the icarus account (as we already have the account password) Seems simple, right? I ran through this all, super excited, sent the request to http://46.101.25.63:31787/reset-2fa?123.jpg and.... got my own account 2FA reset - it wasn't the same OTP key that was cached. Why not!??!?!\nTurns out I had overlooked a key part of the Varnish configuration at the beginning of the VCL file:\n1sub vcl_hash { 2 hash_data(req.url); 3 4 if (req.http.host) { 5 hash_data(req.http.host); 6 } else { 7 hash_data(server.ip); 8 } 9 10 return (lookup); 11} The vcl_hash function is used to determine what elements of a request make it \u0026quot;unique\u0026quot; such that cached results can be looked up and returned (ref. VCL documentat of hashing). In this case, we can see that the Varnish hash is computed by:\nThe URL contents The Host header (if present) or server IP (if header is not present) So in this case, we are not seeing the cached content because the icarus bot is accessing it using the localhost URL as we saw above:\n1\tawait page.goto(\u0026#39;http://127.0.0.1/transactions\u0026#39;, { Therefore, the request http://127.0.0.1/reset-2fa is not equivalent to our request to the external IP address, thus we don't see the cached result. Fortunately this was an easy fix, we simply needed to change the value of the Host header in Burp to 127.0.0.1 to ensure we hit the same Varnish hash entry as icarus hit:\nWe can see in the response presumably the same OTP secret that was saved to the database under icarus's account:\n1\t\u0026lt;script\u0026gt; 2\tgenQRCode(\u0026#39;PFFF2UZEMUGSAN2H\u0026#39;); 3\t\u0026lt;/script\u0026gt; Finishing Up Now that we have the response and a QR code (we can show this page in the browser to get the QR code), the rest of the exercise was simply to log into icarus's account using the stolen OTP secret, transfer funds to our own wallet, and log into our own wallet to see the flag:\nFinal Thoughts Overall this was an extremely fun web challenge that required a number of creative solutions to achieve the seemingly obvious initial goal. I appreciate the designer who put this together!\n","link":"https://h1pmnh.github.io/post/ctf-htb-cyber-apolcalypse-web-genesis-wallet/","section":"post","tags":["ctf","nodejs","varnish","csrf"],"title":"CTF Writeup: 2022 HTB Cyber Apolcalypse Web Challenge: Genesis Wallet"},{"body":"","link":"https://h1pmnh.github.io/tags/nodejs/","section":"tags","tags":null,"title":"nodejs"},{"body":"","link":"https://h1pmnh.github.io/post/","section":"post","tags":["index"],"title":"Posts"},{"body":"","link":"https://h1pmnh.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://h1pmnh.github.io/tags/varnish/","section":"tags","tags":null,"title":"varnish"},{"body":"","link":"https://h1pmnh.github.io/tags/authentication/","section":"tags","tags":null,"title":"authentication"},{"body":"","link":"https://h1pmnh.github.io/tags/cve/","section":"tags","tags":null,"title":"cve"},{"body":"Summary In research related to a Synack Red Team client, I was able to discover several authentication bypass issues in the LuxCal web calendar component. The limited details of these issues, which have been resolved by the vendor in version 5.2.0 of the software, are listed below. As an agreement with the vendor, we are releasing very limited information on this bypass. This resulted in the assignment of 2 CVEs from MITRE.\nCVSS for both is AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H 9.8.\nI'd like to thank the vendor for being extremely responsive to this issue!\nCVE 2021-45914 In LuxSoft LuxCal Web Calendar before 5.20, an unauthenticated attacker can mainipulate a POST request. This allows the attacker's session to be authenticated as any registered LuxCal user, including the site administrator.\nCVE 2021-45915 In LuxSoft LuxCal Web Calendar before 5.20, an unauthenticated attacker can mainipulate a cookie value. This allows the attacker's session to be authenticated as any registered LuxCal user, including the site administrator.\nRemediation Upgrade to version 5.2 of the LuxCal component at the vendor's site here\nMore details are available from the vendor here\nTimeline 2021 Dec 9 - Vendor contacted with details of the vulnerability 2021 Dec 9-23 - Researcher/vendor work together to qualify patch 2022 Jan 15 - Vendor releases V5.2.0 with remediation 2022 May 9 - Public release (agreed on 90 day+ hold time to allow customers to upgrade) ","link":"https://h1pmnh.github.io/post/cve-luxcal-2021/","section":"post","tags":["cve","authentication"],"title":"LuxCal 5.1.x and below Authentication Bypass: CVE-2021-45914, CVE-2021-45915"},{"body":"","link":"https://h1pmnh.github.io/tags/advanced/","section":"tags","tags":null,"title":"advanced"},{"body":"Summary Many new bug bounty hunters will blindly rely on the output of tools to magically find them bugs. As most experienced hunters know, the key to long-term success is to understand how to effectively use the many great tools and fine-tune these tools to achieve results in the form of valuable, challenging bugs.\nSince I joined the Synack Red Team, I have been digging into sqlmap and the intricacies involved in finding SQL injections \u0026quot;in the wild\u0026quot;. This will be the first of hopefully several posts on how to use sqlmap to work around challenging real-world scenarios where SQL injections exist. I hope you find this useful in your research!\nOn Manual Testing In almost all cases I never run sqlmap without first manually confirming the presence of a vulnerability! Don't be an irresponsible hunter - do your research manually or with low-impact scanning first!\nScenario In this scenario I was able to find a SQL injection vulnerability through source code auditing of the application I was testing. The application took a certain parameter and issued 2 SQL queries with it. The first query looked like this (partial query):\n1... select OID from pg_namespace where nspname=\u0026#39;{parameter}\u0026#39; ... If this query succeeded (returned a row), the code would issue a 2nd query as below:\n1select distinct object from {parameter} ... If the first query did not return a row, the code would instead throw a Python error:\n1AttributeError: \u0026#39;NoneType\u0026#39; object has no attribute So this means that in order to pass both queries the {parameter} needed to be a valid string in the first query and a valid table or view name in the 2nd query! Unfortunately this is inherently incompatible with the need to be able to construct a valid boolean true/false expression. I had to find another approach.\nThe Approach I determined that it was not going to be possible to get a payload that would successfully pass both queries, therefore I determined that I had to construct a payload that would satisfy the first query enough to generate a true/false result. \u0026quot;True\u0026quot; would mean the code would successfully execute the first query, and fail in the 2nd query. \u0026quot;False\u0026quot; would mean the code would successfully execute the first query, but because a row was not returned from the query, it would generate the AttributeError message. This got me set up with the \u0026quot;True\u0026quot; and \u0026quot;False\u0026quot; conditions I needed for sqlmap to work properly:\n\u0026quot;True\u0026quot;: Error message contains select distinct object from \u0026quot;False\u0026quot;: Error message contains AttributeError: 'NoneType' One other Wrinkle Because of the nature of the code involved, the SQL injection payload needed to be placed in the middle of the query parameter string in a specific location. Let's say the query parameter looked like this:\n1param=canary.bluebird The position of the SQL injection payload had to be here:\n1param=canary.bluebird 2 ^^ Basically, it had to be placed before the . character, in the middle of the string, in order for the first SQL query to successfully execute.\nValidating the Approach I tested this approach by the following query:\n1param=`cana\u0026#39;||(select/**/\u0026#39;r\u0026#39;/**/where/**/1=1)||\u0026#39;y.bluebird` I confirmed this corresponded to the \u0026quot;true\u0026quot; result (getting past the first SQL query and a syntax error on the 2nd). Changing the 1=1 to 0=1 confirmed the behavior of the \u0026quot;false\u0026quot; result (AttributeError). Great!\nNow, on to getting sqlmap to follow this same manual approach.\nA Couple more Wrinkles A few other wrinkles came up in my manual testing:\nBoth \u0026quot;true\u0026quot; and \u0026quot;false\u0026quot; resulted in an error page with HTTP status 500 The URL parameter had to be issued without URL encoding (i.e. ' instead of %27) Because of this, the inclusion of space characters would break the request, so they had to be replaced with comments /**/ I had to make sure that sqlmap followed these as well.\nWrangling sqlmap Let's get the easy stuff out of the way first:\nDon't encode URL parameters: use the --skip-urlencode flag Change spaces to comments: use the --tamper=space2comment flag to invoke this tamper script Tamper scripts modify the payload before it is sent to the target site! Match HTTP code 500 as part of the \u0026quot;true\u0026quot; result: use the --code=500 flag As an interesting side note: without this, sqlmap will assume a non-2xx status code is a failure (neither true nor false) and will ignore the result Now we need to get the positioning of the payload correct. We can use the --prefix and -suffix flags for this as follows:\n1--prefix=\u0026#34;cana\u0026#39;||\u0026#34; --suffix=\u0026#34;||\u0026#39;y.bluebird\u0026#34; If you are following along, you might wonder where the r character in canary went. Remember the injection point needs to be before the . in the valid parameter string. Remember a valid query \u0026quot;true/false\u0026quot; will look like this:\n1param=`cana\u0026#39;||(select/**/\u0026#39;r\u0026#39;/**/where/**/1=1)||\u0026#39;y.bluebird` You can see the r is being returned from the inner select statement if the where clause evaluates to \u0026quot;true\u0026quot;. If it evaluates to \u0026quot;false\u0026quot;, no value is returned, and we know that the parameter value of canay.bluebird (no r) will return 0 rows. This type of SQL injection corresponds to the sqlmap payload with \u0026quot;original value\u0026quot; in the name.\nTip: sqlmap has two types of payloads: one where the boolean condition returns the original value inline in the query, and the other where the boolean result is appended to the original value (the classic AND 1=1 type of payload) In this case, trying to get an AND 1=1 type payload in the middle of our parameter would make no sense at all! Therefore we're looking only for blind boolean payloads that use the original value in the constructed query string.\nThe final piece of the puzzle is helping sqlmap determine a true vs false result. In this case we use the --string parameter to suggest to sqlmap text that is guaranteed only to appear when the boolean value is true. In our analysis we determined the displayed error message will contain the string select distinct object from.\nPutting it all together, the final sqlmap command line looked like this:\n1...\u0026amp;param=r -p param --prefix=\u0026#34;cana\u0026#39;||\u0026#34; --suffix=\u0026#34;||\u0026#39;y.bluebird\u0026#34; --tamper space2comment --level=3 --risk=2 --string \u0026#34;select distinct object from ucon_p\u0026#34; --code=500 --dbms PostgreSQL --skip-urlencode --no-escape --no-cast --banner --technique=B With this combination of parameters I was able to translate my manual confirmation of the SQLi with the automatic data gathering magic of sqlmap\nFeedback? Hopefully this article was helpful in outlining how to reason through a complex SQL injection vulnerability. If you have any comments or want to collaborate on a report feel free to DM me on Twitter, I'm always open to collaboration with trusted people.\nLinks A couple other resources that cover this sort of advanced sqlmap content well:\nhttps://cybr.com/ethical-hacking-archives/sqlmap-cheat-sheets-to-help-you-find-sql-injections/ https://thegreycorner.com/2017/01/05/exploiting-difficult-sql-injection.html ","link":"https://h1pmnh.github.io/post/advanced-sqlmap-case-study-1/","section":"post","tags":["sqlmap","sqli","advanced"],"title":"Advanced sqlmap Case Study"},{"body":"","link":"https://h1pmnh.github.io/tags/sqli/","section":"tags","tags":null,"title":"sqli"},{"body":"","link":"https://h1pmnh.github.io/tags/sqlmap/","section":"tags","tags":null,"title":"sqlmap"},{"body":"Brief Bio I'm a software developer, architect, author by trade, with years of experience in software large (millions of users) and small startups and non-profits. Recently I took a more active role in a life-long hobby of playing with security, cryptography, and puzzles into a full-on passion for security research, bug bounty, and the like.\nMy Stats I started bug bounty as a hobby in Sep 2020. I've hacked on 3 major platforms, my profiles are linked below:\nHackerOne - ~3200 rep, 7.0 signal, 23.74 impact Bugcrowd - ~500 pts, 100% accuracy, 13 P1s Synack (SRT) - level 0x05 I actively hunted on HackerOne from Sep 2020-Aug 2021. During this time, I was in the top 10 on the US leaderboard, delivering critical and high findings on numerous private and public programs. Towards the end of the year I moved to Bugcrowd, as well as joined the Synack Red Team (SRT), where I perform my primary hunting today, currently maintaining a top 5 position on the global SRT leaderboard.\nMy focus areas are deep recon / research and P1/P2/P3 findings. I'm always happy to discuss techniques around these or collaborate with hackers - ping me on Twitter (@h1pmnh) or Discord (pmnh#8207). I haven't ever intentionally filed a P4/P5, so I can't really help you with questions about this class of bugs.\nWhy Read This Site? This simple site captures some stories and learnings on this journey. I hope you find it useful. I aim to publish once or twice monthly. My goal is to share interesting findings as well as some metrics and learnings as a relative newcomer to this field.\nThis site is not intended for people new to bug bounty, but instead targeting those looking to improve their craft, read more technical articles, and generally \u0026quot;talk shop\u0026quot;. In most cases I won't be explaining commonly Google-able terms and suggest you rely on the many great resources around the web for bug bounty basics.\nFeedback / Questions? Feel free to send any feebdack my way on Twitter, I can be reached at @h1pmnh - unfortunately my social media presence doesn't match my bug bounty platform names, sorry for any confusion :)\n","link":"https://h1pmnh.github.io/about/","section":"","tags":null,"title":"About"},{"body":"","link":"https://h1pmnh.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://h1pmnh.github.io/tags/index/","section":"tags","tags":null,"title":"index"},{"body":"","link":"https://h1pmnh.github.io/series/","section":"series","tags":null,"title":"Series"}]