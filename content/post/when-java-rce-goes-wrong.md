---
title: "When Java RCE Goes Wrong"
date: 2022-04-06T23:07:00-04:00
draft: true
tags: ["rce", "java"]
---

## Summary
This is a post about recognizing when Java Deserialization goes "wrong", some things to watch out for, and possible solutions. Don't give up if you encounter a `URLDNS` pingback but can't get anything else to work!

## Intro
For those who know me in the security community, I focus primarily on interesting bugs requiring deep research and can leverage my many years of experience in software engineering and architecture. Chief among these is Java Deserialization bugs, which rely on several things coming together in order to achieve RCE:

 * The application must use Java deserialization in some form,
 * The application must contain a useful gadget chain which we can leverage to do something impactful,
 * The application must not be protected by a WAF which can intercept deserialization payloads

Although there are many great tools to assist researchers when they encounter Java deserialization bugs, when these tools fail or leave us with less-than-stellar results, what do we do? In this post, I'll describe a great collab I did with [@djurado9](https://twitter.com/djurado9) when he pinged me with a question.

## About Java Deserialization RCEs
There are numerous great articles on Java Deserialization RCEs and a great [cheat sheet](https://github.com/GrrrDog/Java-Deserialization-Cheat-Sheet) as well as a good [PortSwigger lab](https://portswigger.net/web-security/deserialization/exploiting/lab-deserialization-exploiting-java-deserialization-with-apache-commons) on the subject. The basic idea of these vulnerabilities is that:

 * The application reads serialized Java objects from some user input,
 * The attacker can build their own serialized Java object payload,
 * A "gadget chain" exists on the server which, when deserialized, does something impactful

In most cases you will use the excellent [ysoserial](https://github.com/frohoff/ysoserial) tool to generate a payload using one of many well-known gadget chains to generate the serialized payload. Ideally this gadget chain will do something impactful, such as RCE - executing an arbitrary shell command. Gadgets exist to perform other interesting actions, such as running Java code within the JVM, reading files, performing HTTP requests, etc. I hope to cover some of these in a later post.

For now though, our target is maximum impact - RCE through execution of arbitrary shell commands through the use of a payload generated by `ysoserial`.

## Background
@djurado9 had identified an instance of a particular CVE running on a vulnerable server. He was able to get the ysoserial `URLDNS` payload to ping back to Burp Collaborator but wasn't able to use any of the other payloads to achieve RCE.

### What's `URLDNS`?
One of the most innocuous and easily testable payloads for ysoserial, URLDNS (originally documented [here](https://blog.paranoidsoftware.com/triggering-a-dns-lookup-using-java-deserialization/) I believe) will use an interesting behavior of the `java.net.URL` class's `hashCode` method, to generate a DNS request when a URL is placed into a `HashMap` or similar hashed structure in Java.

This payload is great for Java Deserialization canary testing because it relies only on core Java classes (i.e. classes included in the JRE itself, without third-party libraries) and uses DNS pingbacks, which will escape most (but not all) environments and reach Burp Collaborator.